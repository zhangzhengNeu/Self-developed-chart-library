import React, { CSSProperties, ReactNode } from 'react';
import { noop } from 'rxjs';
import { ArtColumn } from '../interfaces';
import getDerivedStateFromProps from './getDerivedStateFromProps';
import { VirtualEnum } from './interfaces';
import { BaseTableCSSVariables } from './styles';
export interface BaseTableProps {
    /** 主键 */
    primaryKey?: string | ((record: any, rowIndex: number) => string);
    /** 表格展示的数据源 */
    dataSource: any[];
    /** 表格的列配置 */
    columns: ArtColumn[];
    /** 是否开启虚拟滚动 */
    useVirtual?: VirtualEnum | {
        horizontal?: VirtualEnum;
        vertical?: VirtualEnum;
        header?: VirtualEnum;
    };
    /** 表格头部是否置顶，默认为 true */
    isStickyHead?: boolean;
    /** 表格置顶后，距离顶部的距离 */
    stickyTop?: number;
    /** 表格置顶后，距离底部的距离 */
    stickyBottom?: number;
    /** 自定义类名 */
    className?: string;
    /** 自定义内联样式 */
    style?: CSSProperties & BaseTableCSSVariables;
    /** 表格是否具有头部 */
    hasHeader?: boolean;
    /** 使用来自外层 div 的边框代替单元格的外边框 */
    useOuterBorder?: boolean;
    /** 表格是否在加载中 */
    isLoading?: boolean;
    /** 数据为空的时候的表格内容展现 */
    emptyContent?: ReactNode;
    /** 列的默认宽度 */
    defaultColumnWidth?: number;
    /** 表格所处于的块格式化上下文(BFC)
     * https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context */
    flowRoot?: 'auto' | 'self' | (() => HTMLElement | typeof window) | HTMLElement | typeof window;
    getRowProps?(record: any, rowIndex: number): React.HTMLAttributes<HTMLTableRowElement>;
}
export interface BaseTableState {
    flat: {
        left: ArtColumn[];
        center: ArtColumn[];
        right: ArtColumn[];
        main: ArtColumn[];
    };
    nested: {
        left: ArtColumn[];
        right: ArtColumn[];
        main: ArtColumn[];
        center: ArtColumn[];
    };
    /** 是否要展示自定义滚动条(stickyScroll) */
    hasScroll: boolean;
    /** 是否需要渲染 lock sections
     * 当表格较宽时，所有的列都能被完整的渲染，此时不需要渲染 lock sections
     * 只有当「整个表格的宽度」小于「每一列渲染宽度之和」时，lock sections 才需要被渲染 */
    needRenderLock: boolean;
    /** 是否需要启用虚拟滚动 */
    useVirtual: {
        horizontal: boolean;
        vertical: boolean;
        header: boolean;
    };
    /** 纵向虚拟滚动偏移量 */
    offsetY: number;
    /** 纵向虚拟滚动 最大渲染尺寸 */
    maxRenderHeight: number;
    /** 横向虚拟滚动偏移量 */
    offsetX: number;
    /** 横向虚拟滚动 最大渲染尺寸 */
    maxRenderWidth: number;
}
export declare class BaseTable extends React.Component<BaseTableProps, BaseTableState> {
    static defaultProps: {
        isStickyHead: boolean;
        stickyTop: number;
        stickyBottom: number;
        useVirtual: string;
        hasHeader: boolean;
        isLoading: boolean;
        getRowProps: typeof noop;
        flowRoot: string;
    };
    static getDerivedStateFromProps: typeof getDerivedStateFromProps;
    private store;
    private artTableRef;
    private artTableWrapperRef;
    private doms;
    private rootSubscription;
    private hoveredTableRows;
    constructor(props: Readonly<BaseTableProps>);
    /** 自定义滚动条宽度为table宽度，使滚动条滑块宽度相同 */
    private updateStickyScroll;
    private renderTableSection;
    private renderTableHeader;
    /**
     * 对于的锁定列和表头，因为我们对其设置了 overflow: hidden，导致在不会触发 scroll 事件。
     * 我们监听其 wheel 事件，然后手动同步 scrollTop/scrollLeft
     */
    private onWheelInOverflowHiddenPart;
    private syncScrollFromMainBody;
    private updateOffsetX;
    /** 同步滚动偏移量 */
    private syncScroll;
    private getVerticalRenderRange;
    private getHorizontalRenderRange;
    private getRenderRange;
    private getFlatHozWrappedCols;
    private renderTableBody;
    private isLock;
    private onRowEnterOrLeave;
    render(): JSX.Element;
    private renderLeftSection;
    private renderMainSection;
    private renderRightSection;
    private didMountOrUpdate;
    componentDidMount(): void;
    private resolveFlowRoot;
    private initSubscriptions;
    componentDidUpdate(prevProps: Readonly<BaseTableProps>): void;
    componentWillUnmount(): void;
    /** 更新 DOM 节点的引用，方便其他方法直接操作 DOM */
    private updateDoms;
    private updateItemSizeStore;
    private adjustLoadingPosition;
    private adjustSize;
    private adjustSizeOfLockCells;
    private adjustSizeOfLockBodies;
    /** 更新左右两侧锁列表头的 tr 的高度 */
    private adjustSizeOfLockHeaderCells;
    /** 计算表格所有列的渲染宽度之和，判断表格是否需要渲染锁列 */
    private adjustNeedRenderLock;
}
