import React, { useState } from 'react';
import { fromEvent } from 'rxjs';
import { takeUntil, map } from 'rxjs/operators';
import { b as isLeafNode, f as flatMap, g as getTreeDepth, c as collectNodes, s as safeGetValue, d as safeGetCellProps, S as SpanManager, _ as __rest, e as safeRenderHeader, h as _objectWithoutProperties, I as Icon, j as _extends } from './ali-react-table-treeMode-d713dac0.esm.js';
import styled__default from 'styled-components';
import merge from 'lodash.merge';

/**
 * 以 input 作为输入，按序使用 transform.
 *
 * `applyTransform(input, f1, f2, f3)` 等价于 `f3(f2(f1(input)))` */
function applyTransforms(input, ...transforms) {
    return transforms.reduce((v, fn) => fn(v), input);
}

function normalizeAsArray(input) {
    if (input == null) {
        return [];
    }
    else if (Array.isArray(input)) {
        return input;
    }
    else {
        return [input];
    }
}
function traverseColumn(fn) {
    return ({ columns, dataSource }) => {
        return { dataSource, columns: dfs(columns, 0).result };
        function dfs(columns, parentStartColIndex) {
            let flatColCount = 0;
            const result = [];
            for (const col of columns) {
                const startColIndex = parentStartColIndex + flatColCount;
                let unNormalized;
                if (isLeafNode(col)) {
                    unNormalized = fn(col, {
                        range: { start: startColIndex, end: startColIndex + 1 },
                        dataSource,
                    });
                    flatColCount += 1;
                }
                else {
                    const dfsResult = dfs(col.children, startColIndex);
                    unNormalized = fn(Object.assign(Object.assign({}, col), { children: dfsResult.result }), {
                        range: {
                            start: startColIndex,
                            end: startColIndex + dfsResult.flatColCount,
                        },
                        dataSource,
                    });
                    flatColCount += dfsResult.flatColCount;
                }
                result.push(...normalizeAsArray(unNormalized));
            }
            return { result, flatColCount };
        }
    };
}

/**
 * 根据 idProp 与 parentIdProp 从对象数组中构建对应的树
 * 当 A[parentIdProp] === B[idProp] 时，对象A会被移动到对象B的children。
 * 当一个对象的 parentIdProp 不与其他对象的 idProp 字段相等时，该对象被作为树的顶层节点
 * @example
 * const array = [
 *   { id: 'node-1', parent: 'root' },
 *   { id: 'node-2', parent: 'root' },
 *   { id: 'node-3', parent: 'node-2' },
 *   { id: 'node-4', parent: 'node-2' },
 *   { id: 'node-5', parent: 'node-4' },
 * ]
 * const tree = buildTree('id', 'parent', array)
 * expect(tree).toEqual([
 *   { id: 'node-1', parent: 'root' },
 *   {
 *     id: 'node-2',
 *     parent: 'root',
 *     children: [
 *       { id: 'node-3', parent: 'node-2' },
 *       {
 *         id: 'node-4',
 *         parent: 'node-2',
 *         children: [{ id: 'node-5', parent: 'node-3' }],
 *       },
 *     ],
 *   },
 * ])
 */
function buildTree(idProp, parentIdProp, items) {
    const wrapperMap = new Map();
    const ensure = (id) => {
        if (wrapperMap.has(id)) {
            return wrapperMap.get(id);
        }
        const wrapper = { id, parent: null, item: null, children: [] };
        wrapperMap.set(id, wrapper);
        return wrapper;
    };
    for (const item of items) {
        const parentWrapper = ensure(item[parentIdProp]);
        const itemWrapper = ensure(item[idProp]);
        itemWrapper.parent = parentWrapper;
        parentWrapper.children.push(itemWrapper);
        itemWrapper.item = item;
    }
    const topLevelWrappers = flatMap(Array.from(wrapperMap.values()).filter((wrapper) => wrapper.parent == null), (wrapper) => wrapper.children);
    return unwrapRecursively(topLevelWrappers);
    function unwrapRecursively(wrapperArray) {
        const result = [];
        for (const wrapper of wrapperArray) {
            if (wrapper.children.length === 0) {
                result.push(wrapper.item);
            }
            else {
                result.push(Object.assign(Object.assign({}, wrapper.item), { children: unwrapRecursively(wrapper.children) }));
            }
        }
        return result;
    }
}

function safeGetSpanRect(column, record, rowIndex, colIndex) {
    let colSpan = 1;
    let rowSpan = 1;
    if (column.getSpanRect) {
        const value = safeGetValue(column, record, rowIndex);
        const spanRect = column.getSpanRect(value, record, rowIndex);
        colSpan = spanRect == null ? 1 : spanRect.right - colIndex;
        rowSpan = spanRect == null ? 1 : spanRect.bottom - rowIndex;
    }
    else {
        const cellProps = safeGetCellProps(column, record, rowIndex);
        if (cellProps.colSpan != null) {
            colSpan = cellProps.colSpan;
        }
        if (cellProps.rowSpan != null) {
            rowSpan = cellProps.rowSpan;
        }
    }
    // 注意这里没有考虑「rowSpan/colSpan 不能过大，避免 rowSpan/colSpan 影响因虚拟滚动而未渲染的单元格」
    return {
        top: rowIndex,
        bottom: rowIndex + rowSpan,
        left: colIndex,
        right: colIndex + colSpan,
    };
}
function move({ c, r }, dx, dy) {
    return { c: c + dx, r: r + dy };
}
function sanitizeCellDatum(value) {
    if (value === Infinity || value === -Infinity || (typeof value === 'number' && isNaN(value))) {
        return null;
    }
    else {
        return value;
    }
}
/** 根据 BaseTable 的 dataSource 和 column，将表格数据导出为 Excel 文件 */
function exportTableAsExcel(xlsxPackage, dataSource, columns, filename) {
    const sheet = xlsxPackage.utils.aoa_to_sheet([]);
    const topHeaderHeight = getTreeDepth(columns) + 1;
    const origin = { c: 0, r: 0 };
    addTopHeaders(origin);
    addDataPart(move(origin, 0, topHeaderHeight));
    xlsxPackage.writeFile({
        SheetNames: ['Sheet1'],
        Sheets: { Sheet1: sheet },
    }, filename);
    function addTopHeaders(origin) {
        dfs(columns, 0, 0);
        function dfs(cols, startDx, startDy) {
            var _a;
            const start = move(origin, startDx, startDy);
            let offsetX = 0;
            for (const col of cols) {
                if ((_a = col.features) === null || _a === void 0 ? void 0 : _a.noExport) {
                    continue;
                }
                const current = move(start, offsetX, 0);
                addOne(col.name, current);
                if (isLeafNode(col)) {
                    offsetX += 1;
                    mergeCells(current, 1, topHeaderHeight - startDy);
                }
                else {
                    const childrenWidth = dfs(col.children, startDx + offsetX, startDy + 1);
                    mergeCells(current, childrenWidth, 1);
                    offsetX += childrenWidth;
                }
            }
            return offsetX;
        }
    }
    function addDataPart(origin) {
        const leafColumns = collectNodes(columns, 'leaf-only').filter((col) => { var _a; return !((_a = col.features) === null || _a === void 0 ? void 0 : _a.noExport); });
        const spanManager = new SpanManager();
        const dataPart = dataSource.map((record, rowIndex) => {
            spanManager.stripUpwards(rowIndex);
            return leafColumns.map((col, colIndex) => {
                if (spanManager.testSkip(rowIndex, colIndex)) {
                    return null;
                }
                const spanRect = safeGetSpanRect(col, record, rowIndex, colIndex);
                const rowSpan = spanRect.bottom - spanRect.top;
                const colSpan = spanRect.right - spanRect.left;
                if (rowSpan > 1 || colSpan > 1) {
                    spanManager.add(spanRect.top, spanRect.left, colSpan, rowSpan);
                    mergeCells(move(origin, spanRect.left, spanRect.top), colSpan, rowSpan);
                }
                return sanitizeCellDatum(safeGetValue(col, record, rowIndex));
            });
        });
        add(dataPart, origin);
    }
    function add(data, origin) {
        xlsxPackage.utils.sheet_add_aoa(sheet, data, { origin });
    }
    function addOne(datum, origin) {
        xlsxPackage.utils.sheet_add_aoa(sheet, [[datum]], { origin });
    }
    function mergeCells(addr, width, height) {
        if (width === 1 && height === 1) {
            return;
        }
        if (sheet['!merges'] == null) {
            sheet['!merges'] = [];
        }
        sheet['!merges'].push({ s: addr, e: move(addr, width - 1, height - 1) });
    }
}

/** 对树状结构的数据进行排序.
 * layeredSort 是一个递归的过程，针对树上的每一个父节点，该函数都会重新对其子节点数组（children) 进行排序.
 * */
function layeredSort(array, compare) {
    return dfs(array);
    function dfs(rows) {
        if (!Array.isArray(array)) {
            return array;
        }
        return rows
            .map((row) => {
            if (isLeafNode(row)) {
                return row;
            }
            return Object.assign(Object.assign({}, row), { children: dfs(row.children) });
        })
            .sort(compare);
    }
}

/** 合并两个 cellProps（单元格属性）对象。
 *
 * mergeCellProps 会按照「单元格属性的性质」来合并两个对象：
 * * 对于 数字、字符串、布尔值类型的字段，extra 中的字段值将直接覆盖 base 中的字段值
 * * 对于函数/方法类型的字段（对应单元格的事件回调函数），mergeCellProps 将生成一个新的函数，新函数将按序调用 base 和 extra 中的方法
 * * 对于普通对象类型的字段（一般对应单元格的样式），mergeCellProps 将调用 lodash.merge 来合并字段值 */
function mergeCellProps(base, extra) {
    if (base == null) {
        return extra;
    }
    const result = Object.assign({}, base);
    for (const key of Object.keys(extra)) {
        const value = extra[key];
        const type = typeof value;
        if (value == null || type === 'undefined' || type === 'number' || type === 'string' || type === 'boolean') {
            result[key] = value;
        }
        else if (type === 'function') {
            const prev = result[key];
            if (prev == null) {
                result[key] = value;
            }
            else {
                result[key] = (...args) => {
                    // 先执行原有的事件回调函数
                    prev(args);
                    value(args);
                    // 事件回调函数没有返回值，故这里不进行 return
                };
            }
        }
        else if (type === 'object') {
            result[key] = merge(result[key], value);
        }
        // else `type` is 'bigint' or 'symbol', `value` is an invalid cellProp, ignore it
    }
    return result;
}

const factorySymbol = Symbol('factory-symbol');
function isProtoFactory(v) {
    return v && v[factorySymbol];
}
function proto(baseRecord, ensureArray = 'auto') {
    const baseKeys = Object.keys(baseRecord);
    function process(record) {
        const result = Object.assign({}, record);
        baseKeys.forEach((key) => {
            var _a;
            if (result[key] === proto.empty) {
                delete result[key];
                return;
            }
            const base = baseRecord[key];
            if (isProtoFactory(base)) {
                result[key] = base(result[key]);
            }
            else {
                result[key] = (_a = result[key]) !== null && _a !== void 0 ? _a : base;
            }
        });
        return result;
    }
    function factory(arg) {
        const isEnsureArray = ensureArray === 'auto' ? Array.isArray(arg) : ensureArray;
        if (isEnsureArray) {
            if (arg == null) {
                return [];
            }
            return arg.map(process);
        }
        else {
            return process(arg);
        }
    }
    // @ts-ignore
    factory[factorySymbol] = true;
    factory.extends = (extRecord) => {
        const extFactory = proto(extRecord, ensureArray);
        return (arg) => factory(extFactory(arg));
    };
    return factory;
}
proto.empty = Symbol('proto.empty');
proto.string = ((v) => {
    if (v != null && typeof v !== 'string') {
        throw new Error('must be string');
    }
    return v;
});
proto.string[factorySymbol] = true;
proto.number = ((v) => {
    if (v != null && typeof v !== 'number') {
        throw new Error('must be number');
    }
    return v;
});
proto.number[factorySymbol] = true;
proto.notNull = ((v) => {
    if (v == null) {
        throw new Error('must be not null');
    }
    return v;
});
proto.notNull[factorySymbol] = true;
proto.object = (baseRecord) => proto(baseRecord, false);
proto.array = (baseRecord) => proto(baseRecord, true);

/** 比较函数，支持字符串、数字、数组和 null。
 * * 对于字符串将比较两者的字典序；
 * * 对数字将比较两者大小；
 * * null 值在比较时总是小于另一个值；
 * * 对于数组来说，将逐个比较数组中的元素，第一个不相等的比较结果将作为整个数组的比较结果
 *
 * 数组的比较可参考 python 中的元祖比较：
 * https://stackoverflow.com/questions/5292303/how-does-tuple-comparison-work-in-python */
function smartCompare(x, y) {
    // 将 null 排在最后面
    if (x == null) {
        return 1;
    }
    if (y == null) {
        return -1;
    }
    if (typeof x === 'number' && typeof y === 'number') {
        return x - y;
    }
    if (typeof x === 'string' && typeof y === 'string') {
        // 字符串使用 默认的字典序
        if (x < y) {
            return -1;
        }
        else if (x > y) {
            return 1;
        }
        else {
            return 0;
        }
    }
    if (Array.isArray(x) && Array.isArray(y)) {
        const len = Math.min(x.length, y.length);
        for (let i = 0; i < len; i++) {
            const cmp = smartCompare(x[i], y[i]);
            if (cmp !== 0) {
                return cmp;
            }
        }
        // 数组长度不等时，元素少的字段放在前面
        return x.length - y.length;
    }
    // 对于不认识的数据类型，返回 0
    return 0;
}

function isIdentity(x, y) {
    return x === y;
}
function makeAutoRowSpanTransform() {
    return traverseColumn((col, { dataSource, range }) => {
        var _a;
        if (!((_a = col.features) === null || _a === void 0 ? void 0 : _a.autoRowSpan)) {
            return col;
        }
        if (!isLeafNode(col)) {
            return col;
        }
        const isFunc = typeof col.features.autoRowSpan === 'function';
        const shouldMergeCell = isFunc ? col.features.autoRowSpan : isIdentity;
        const spanRects = [];
        let lastBottom = 0;
        let prevValue = null;
        for (let rowIndex = 0; rowIndex < dataSource.length; rowIndex++) {
            const value = safeGetValue(col, dataSource[rowIndex], rowIndex);
            if (rowIndex === 0 || !shouldMergeCell(prevValue, value)) {
                const spanRect = {
                    top: lastBottom,
                    bottom: rowIndex,
                    left: range.start,
                    right: range.end,
                };
                for (let i = lastBottom; i < rowIndex; i++) {
                    spanRects.push(spanRect);
                }
                lastBottom = rowIndex;
            }
            prevValue = value;
        }
        for (let i = lastBottom; i < dataSource.length; i++) {
            spanRects.push({
                top: lastBottom,
                bottom: dataSource.length,
                left: range.start,
                right: range.end,
            });
        }
        return Object.assign(Object.assign({}, col), { getSpanRect(value, row, rowIndex) {
                return spanRects[rowIndex];
            } });
    });
}

function makeBuildTreeTransform(idProp, parentIdProp) {
    return ({ columns, dataSource }) => {
        return { columns, dataSource: buildTree(idProp, parentIdProp, dataSource) };
    };
}

function makeColumnHoverTransform({ hoverColor = '#f5f5f5', hoverColIndex, onChangeHoverColIndex, }) {
    return traverseColumn((col, { range }) => {
        if (!isLeafNode(col)) {
            return col;
        }
        const colIndexMatched = range.start <= hoverColIndex && hoverColIndex < range.end;
        const prevGetCellProps = col.getCellProps;
        return Object.assign(Object.assign({}, col), { getCellProps(value, record, rowIndex) {
                const prevCellProps = prevGetCellProps === null || prevGetCellProps === void 0 ? void 0 : prevGetCellProps(value, record, rowIndex);
                return mergeCellProps(prevCellProps, {
                    style: { backgroundColor: colIndexMatched ? hoverColor : undefined },
                    onMouseEnter() {
                        onChangeHoverColIndex(range.start);
                    },
                    onMouseLeave() {
                        onChangeHoverColIndex(-1);
                    },
                });
            } });
    });
}
function useColumnHoverTransform({ hoverColor, defaultHoverColIndex = -1, } = {}) {
    const [hoverColIndex, onChangeHoverColIndex] = useState(defaultHoverColIndex);
    return makeColumnHoverTransform({ hoverColor, hoverColIndex, onChangeHoverColIndex });
}

const EMPTY_RANGE = {
    start: -1,
    end: -1,
};
function makeColumnRangeHoverTransform({ hoverColor = '#f5f5f5', headerHoverColor = '#ddd', hoverRange, onChangeHoverRange, }) {
    return traverseColumn((col, { range: colRange }) => {
        const match = colRange.end > hoverRange.start && hoverRange.end > colRange.start;
        if (!isLeafNode(col)) {
            if (headerHoverColor == null) {
                return col;
            }
            return Object.assign(Object.assign({}, col), { headerCellProps: mergeCellProps(col.headerCellProps, {
                    onMouseEnter() {
                        onChangeHoverRange(colRange);
                    },
                    onMouseLeave() {
                        onChangeHoverRange(EMPTY_RANGE);
                    },
                    style: { backgroundColor: match ? headerHoverColor : undefined },
                }) });
        }
        const prevGetCellProps = col.getCellProps;
        return Object.assign(Object.assign({}, col), { headerCellProps: mergeCellProps(col.headerCellProps, {
                onMouseEnter() {
                    onChangeHoverRange(colRange);
                },
                onMouseLeave() {
                    onChangeHoverRange(EMPTY_RANGE);
                },
                style: { backgroundColor: match ? headerHoverColor : undefined },
            }), getCellProps(value, record, rowIndex) {
                const prevCellProps = prevGetCellProps === null || prevGetCellProps === void 0 ? void 0 : prevGetCellProps(value, record, rowIndex);
                return mergeCellProps(prevCellProps, {
                    onMouseEnter() {
                        onChangeHoverRange(colRange);
                    },
                    onMouseLeave() {
                        onChangeHoverRange(EMPTY_RANGE);
                    },
                    style: { backgroundColor: match ? hoverColor : undefined },
                });
            } });
    });
}
function useColumnHoverRangeTransform({ hoverColor, headerHoverColor, defaultHoverRange = EMPTY_RANGE, } = {}) {
    const [hoverRange, onChangeHoverRange] = useState(defaultHoverRange);
    return makeColumnRangeHoverTransform({ hoverColor, headerHoverColor, hoverRange, onChangeHoverRange });
}

function clamp(min, x, max) {
    return Math.max(min, Math.min(max, x));
}
const ResizeHandle = styled__default.span `
  position: absolute;
  top: 0;
  bottom: 0;
  right: -5px;
  width: 10px;
  cursor: col-resize;
  z-index: 1;
`;
function makeColumnResizeTransform({ sizes, onChangeSizes, minSize = 40, maxSize = Infinity, appendExpander, disableUserSelectWhenResizing, }) {
    const startResize = (colIndex, e) => {
        const startX = e.clientX;
        const startSize = sizes[colIndex];
        const nextSizes$ = fromEvent(window, 'mousemove').pipe(takeUntil(fromEvent(window, 'mouseup')), map((e) => {
            const movingX = e.clientX;
            const nextSizes = sizes.slice();
            nextSizes[colIndex] = clamp(minSize, startSize + (movingX - startX), maxSize);
            return nextSizes;
        }));
        let prevUserSelect = '';
        let docElemStyle;
        if (disableUserSelectWhenResizing) {
            docElemStyle = document.documentElement.style;
            prevUserSelect = docElemStyle.userSelect;
            docElemStyle.userSelect = 'none';
            docElemStyle.cursor = 'col-resize';
        }
        nextSizes$.subscribe({
            next: onChangeSizes,
            complete() {
                if (disableUserSelectWhenResizing) {
                    docElemStyle.userSelect = prevUserSelect;
                }
            },
        });
    };
    const innerTransform = traverseColumn((col, { range }) => {
        var _a;
        if (!isLeafNode(col)) {
            return col;
        }
        const prevTitle = safeRenderHeader(col);
        return Object.assign(Object.assign({}, col), { width: sizes[range.start], title: (React.createElement(React.Fragment, null,
                prevTitle,
                React.createElement(ResizeHandle, { className: "resize-handle", onMouseDown: (e) => startResize(range.start, e) }))), headerCellProps: Object.assign(Object.assign({}, col.headerCellProps), { style: Object.assign(Object.assign({}, (_a = col.headerCellProps) === null || _a === void 0 ? void 0 : _a.style), { overflow: 'visible', position: 'relative' }) }) });
    });
    return (input) => {
        const { columns, dataSource } = innerTransform(input);
        return {
            columns: appendExpander ? columns.concat([{ name: '' }]) : columns,
            dataSource,
        };
    };
}
function useColumnResizeTransform(_a) {
    var { defaultSizes } = _a, others = __rest(_a, ["defaultSizes"]);
    const [sizes, onChangeSizes] = useState(defaultSizes);
    return makeColumnResizeTransform(Object.assign({ sizes, onChangeSizes }, others));
}

function makeFlattenTransform() {
    return traverseColumn((column) => {
        var _a;
        if (isLeafNode(column)) {
            return column;
        }
        return ((_a = column.features) === null || _a === void 0 ? void 0 : _a.flatten) ? column.children : column;
    });
}

function makeOrderFieldTransform(startOrder = 1) {
    return traverseColumn((column) => {
        var _a, _b;
        if (((_a = column.features) === null || _a === void 0 ? void 0 : _a.order) || ((_b = column.features) === null || _b === void 0 ? void 0 : _b.orderField)) {
            return Object.assign(Object.assign({}, column), { getValue(record, index) {
                    return index + startOrder;
                } });
        }
        return column;
    });
}

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M8.5 11L8.5 6.5 6.5 6.5 6.5 7.5 7.5 7.5 7.5 11 6 11 6 12 10 12 10 11zM8 3.5c-.4 0-.8.3-.8.8S7.6 5 8 5c.4 0 .8-.3.8-.8S8.4 3.5 8 3.5z"
});

var _ref3 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M8,15c-3.9,0-7-3.1-7-7s3.1-7,7-7s7,3.1,7,7S11.9,15,8,15z M8,2C4.7,2,2,4.7,2,8s2.7,6,6,6s6-2.7,6-6S11.3,2,8,2z"
});

var Information16 = /*#__PURE__*/React.forwardRef(function Information16(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2, _ref3, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$1 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M16,10V22h0V10m1-1H12v2h3V21H12v2h8V21H17V9Z"
});

var Number_116 = /*#__PURE__*/React.forwardRef(function Number_116(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$1, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$2 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M20,23H12V17a2,2,0,0,1,2-2h4V11H12V9h6a2,2,0,0,1,2,2v4a2,2,0,0,1-2,2H14v4h6Z"
});

var Number_216 = /*#__PURE__*/React.forwardRef(function Number_216(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$2, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$3 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M18,9H12v2h6v4H14v2h4v4H12v2h6a2,2,0,0,0,2-2V11A2,2,0,0,0,18,9Z"
});

var Number_316 = /*#__PURE__*/React.forwardRef(function Number_316(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$3, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$4 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M18,10v8h0V10m1-1H17v8H14V9H12V19h5v4h2V19h1V17H19V9Z"
});

var Number_416 = /*#__PURE__*/React.forwardRef(function Number_416(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$4, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$5 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M18,23H12V21h6V17H12V9h8v2H14v4h4a2,2,0,0,1,2,2v4A2,2,0,0,1,18,23Z"
});

var Number_516 = /*#__PURE__*/React.forwardRef(function Number_516(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$5, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$6 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M18,14H14V11h5V9H14a2,2,0,0,0-2,2V21a2,2,0,0,0,2,2h4a2,2,0,0,0,2-2V16A2,2,0,0,0,18,14Zm-4,7V16h4v5Z"
});

var Number_616 = /*#__PURE__*/React.forwardRef(function Number_616(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$6, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$7 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M20 9L12 9 12 13 14 13 14 11 17.85 11 13 23 15.16 23 20 11 20 9z"
});

var Number_716 = /*#__PURE__*/React.forwardRef(function Number_716(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$7, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$8 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M18,9H14a2,2,0,0,0-2,2V21a2,2,0,0,0,2,2h4a2,2,0,0,0,2-2V11A2,2,0,0,0,18,9Zm0,2v4H14V11ZM14,21V17h4v4Z"
});

var Number_816 = /*#__PURE__*/React.forwardRef(function Number_816(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$8, children);
});

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2$9 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M18,9H14a2,2,0,0,0-2,2v5a2,2,0,0,0,2,2h4v3H13v2h5a2,2,0,0,0,2-2V11A2,2,0,0,0,18,9Zm0,7H14V11h4Z"
});

var Number_916 = /*#__PURE__*/React.forwardRef(function Number_916(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2$9, children);
});

function SortIcon({ size = 32, style, className, order, }) {
    return (React.createElement("svg", { style: style, className: className, focusable: "false", preserveAspectRatio: "xMidYMid meet", width: size, height: size, viewBox: "0 0 32 32", "aria-hidden": "true" },
        React.createElement("path", { fill: order === 'asc' ? '#23A3FF' : '#bfbfbf', transform: "translate(0, 4)", d: "M8 8L16 0 24 8z" }),
        React.createElement("path", { fill: order === 'desc' ? '#23A3FF' : '#bfbfbf', transform: "translate(0, -4)", d: "M24 24L16 32 8 24z " })));
}
const NumberIconMap = {
    1: Number_116,
    2: Number_216,
    3: Number_316,
    4: Number_416,
    5: Number_516,
    6: Number_616,
    7: Number_716,
    8: Number_816,
    9: Number_916,
};
const EmptyIcon = () => null;
function DefaultSortHeaderCell({ children, column, onToggle, sortOrder, sortIndex, sortOptions }) {
    // 通过 justify-content 来与 col.align 保持对齐方向一致
    const justifyContent = column.align === 'right' ? 'flex-end' : column.align === 'center' ? 'center' : 'flex-start';
    let NumberIcon = EmptyIcon;
    if (sortOptions.mode === 'multiple') {
        if (NumberIconMap[sortIndex + 1] != null) {
            NumberIcon = NumberIconMap[sortIndex + 1];
        }
    }
    return (React.createElement(TableHeaderCell, { onClick: onToggle, style: { justifyContent } },
        children,
        React.createElement(SortIcon, { style: { marginLeft: 2, flexShrink: 0 }, size: 16, order: sortOrder }),
        React.createElement(NumberIcon, { style: { fill: '#666', flexShrink: 0 } })));
}
function hasAnySortableColumns(cols) {
    return cols.some((col) => { var _a; return Boolean((_a = col.features) === null || _a === void 0 ? void 0 : _a.sortable) || (!isLeafNode(col) && hasAnySortableColumns(col.children)); });
}
const TableHeaderCell = styled__default.div `
  cursor: pointer;
  display: flex;
  align-items: center;
`;
function makeSortTransform({ sorts: inputSorts, onChangeSorts: inputOnChangeSorts, orders = ['desc', 'asc', 'none'], mode = 'multiple', SortHeaderCell, keepDataSource, }) {
    const filteredInputSorts = inputSorts.filter((s) => s.order !== 'none');
    // 单字段排序的情况下 sorts 中只有第一个排序字段才会生效
    const sorts = mode === 'multiple' ? filteredInputSorts : filteredInputSorts.slice(0, 1);
    const onChangeSorts = mode === 'multiple'
        ? inputOnChangeSorts
        : (nextSorts) => {
            // 单字段排序的情况下，nextSorts 中只有最后一个排序字段才会生效
            const len = nextSorts.length;
            inputOnChangeSorts(nextSorts.slice(len - 1));
        };
    const sortOptions = { sorts, onChangeSorts, orders, mode, keepDataSource };
    const sortMap = new Map(sorts.map((sort, index) => [sort.code, Object.assign({ index }, sort)]));
    return ({ dataSource, columns }) => {
        if (process.env.NODE_ENV !== 'production') {
            if (!hasAnySortableColumns(columns)) {
                console.warn('ali-react-table commonTransform.sort 缺少可排序的列，请通过 column.features.sortable 来指定哪些列可排序', columns);
            }
        }
        return { columns: processColumns(columns), dataSource: processDataSource(dataSource) };
        function processDataSource(dataSource) {
            if (keepDataSource) {
                return dataSource;
            }
            const sortColumnsMap = new Map(collectNodes(columns, 'leaf-only')
                .filter((col) => { var _a; return ((_a = col.features) === null || _a === void 0 ? void 0 : _a.sortable) != null; })
                .map((col) => [col.code, col]));
            return layeredSort(dataSource, (x, y) => {
                for (const { code, order } of sorts) {
                    const column = sortColumnsMap.get(code);
                    // 如果 code 对应的 column 不可排序，我们跳过该 code
                    if (column == null) {
                        continue;
                    }
                    const sortable = column.features.sortable;
                    const compareFn = typeof sortable === 'function' ? sortable : smartCompare;
                    const xValue = safeGetValue(column, x, -1);
                    const yValue = safeGetValue(column, y, -1);
                    const cmp = compareFn(xValue, yValue);
                    if (cmp !== 0) {
                        return cmp * (order === 'asc' ? 1 : -1);
                    }
                }
                return 0;
            });
        }
        // 在「升序 - 降序 - 不排序」之间不断切换
        function toggle(code) {
            const sort = sortMap.get(code);
            if (sort == null) {
                onChangeSorts(sorts.concat([{ code, order: orders[0] }]));
            }
            else {
                const index = sorts.findIndex((s) => s.code === code);
                const nextSorts = sorts.slice(0, index + 1);
                const nextOrder = getNextOrder(sort.order);
                if (nextOrder === 'none') {
                    nextSorts.pop();
                }
                else {
                    nextSorts[index].order = nextOrder;
                }
                onChangeSorts(nextSorts);
            }
        }
        function processColumns(columns) {
            return columns.map(dfs);
            function dfs(col) {
                var _a;
                const result = Object.assign({}, col);
                if (col.code && (((_a = col.features) === null || _a === void 0 ? void 0 : _a.sortable) || sortMap.has(col.code))) {
                    let sortIndex = -1;
                    let sortOrder = 'none';
                    if (sortMap.has(col.code)) {
                        const { order, index } = sortMap.get(col.code);
                        sortOrder = order;
                        sortIndex = index;
                    }
                    const SortHeaderCellComponent = SortHeaderCell !== null && SortHeaderCell !== void 0 ? SortHeaderCell : DefaultSortHeaderCell;
                    result.title = (React.createElement(SortHeaderCellComponent, { onToggle: () => toggle(col.code), sortOrder: sortOrder, column: col, sortIndex: sortIndex, sortOptions: sortOptions }, safeRenderHeader(col)));
                }
                if (!isLeafNode(col)) {
                    result.children = col.children.map(dfs);
                }
                return result;
            }
        }
    };
    function getNextOrder(order) {
        const idx = orders.indexOf(order);
        return orders[idx === orders.length - 1 ? 0 : idx + 1];
    }
}
function useSortTransform(_a = {}) {
    var { defaultSorts = [] } = _a, others = __rest(_a, ["defaultSorts"]);
    const [sorts, onChangeSorts] = useState(defaultSorts);
    return makeSortTransform(Object.assign({ sorts, onChangeSorts }, others));
}

const HeaderCellWithTips = styled__default.div `
  display: flex;
  align-items: center;

  .tip-icon-wrapper {
    margin-left: 2px;
  }

  .tip-icon {
    display: flex;
    fill: currentColor;
  }
`;
function makeTipsTransform({ Balloon }) {
    return traverseColumn((col) => {
        var _a;
        if (!((_a = col.features) === null || _a === void 0 ? void 0 : _a.tips)) {
            return col;
        }
        const justifyContent = col.align === 'right' ? 'flex-end' : col.align === 'center' ? 'center' : 'flex-start';
        return Object.assign(Object.assign({}, col), { title: (React.createElement(HeaderCellWithTips, { style: { justifyContent } },
                safeRenderHeader(col),
                React.createElement(Balloon, { closable: false, trigger: React.createElement("div", { className: "tip-icon-wrapper" },
                        React.createElement(Information16, { className: "tip-icon" })) }, col.features.tips))) });
    });
}

function makeVisibleTransform(visibleCodes) {
    const set = new Set(visibleCodes);
    return traverseColumn((column) => {
        if (!isLeafNode(column)) {
            return column;
        }
        return set.has(column.code) ? column : Object.assign(Object.assign({}, column), { hidden: true });
    });
}

export { applyTransforms as a, buildTree as b, makeAutoRowSpanTransform as c, makeBuildTreeTransform as d, exportTableAsExcel as e, makeColumnHoverTransform as f, makeColumnRangeHoverTransform as g, useColumnHoverRangeTransform as h, makeColumnResizeTransform as i, useColumnResizeTransform as j, makeFlattenTransform as k, layeredSort as l, mergeCellProps as m, makeOrderFieldTransform as n, makeSortTransform as o, proto as p, useSortTransform as q, makeTipsTransform as r, smartCompare as s, traverseColumn as t, useColumnHoverTransform as u, makeVisibleTransform as v };
