import cx from 'classnames';
import React, { useState } from 'react';
import { defer, fromEvent, asyncScheduler, BehaviorSubject, merge, Observable, Subscription, noop } from 'rxjs';
import { throttleTime, map, mapTo, scan, filter, distinctUntilChanged } from 'rxjs/operators';
import styled__default, { createGlobalStyle } from 'styled-components';
import ResizeObserver from 'resize-observer-polyfill';
import PropTypes from 'prop-types';

function safeRenderHeader(column) {
    var _a;
    return (_a = column.title) !== null && _a !== void 0 ? _a : column.name;
}
function safeGetValue(column, record, rowIndex) {
    if (column.getValue) {
        return column.getValue(record, rowIndex);
    }
    return record[column.code];
}
function safeGetRowKey(primaryKey, record, rowIndex) {
    let key;
    if (typeof primaryKey === 'string') {
        key = record[primaryKey];
    }
    else if (typeof primaryKey === 'function') {
        key = primaryKey(record, rowIndex);
    }
    if (key == null) {
        key = String(rowIndex);
    }
    return key;
}
function safeGetCellProps(column, record, rowIndex) {
    if (column.getCellProps) {
        const value = safeGetValue(column, record, rowIndex);
        return column.getCellProps(value, record, rowIndex) || {};
    }
    return {};
}
function safeRender(column, record, rowIndex) {
    const value = safeGetValue(column, record, rowIndex);
    if (column.render) {
        return column.render(value, record, rowIndex);
    }
    return value;
}

var internals = /*#__PURE__*/Object.freeze({
  __proto__: null,
  safeRenderHeader: safeRenderHeader,
  safeGetValue: safeGetValue,
  safeGetRowKey: safeGetRowKey,
  safeGetCellProps: safeGetCellProps,
  safeRender: safeRender
});

const prefix = 'art-';
// artTableWrapper modifiers: use-outer-border
// artTable modifiers: lock empty sticky has-header
const Classes = {
    /** BaseTable 表格组件的外层包裹 div */
    artTableWrapper: `${prefix}table-wrapper`,
    /** BaseTable 主要内容 div；包含 3 个 left/main/right section */
    artTable: `${prefix}table`,
    lockShadow: `${prefix}lock-shadow`,
    mainSection: `${prefix}main-section`,
    leftSection: `${prefix}left-section`,
    rightSection: `${prefix}right-section`,
    tableInner: `${prefix}table-inner`,
    tableHeaderWrapper: `${prefix}table-header-wrapper`,
    tableHeader: `${prefix}table-header`,
    tableBody: `${prefix}table-body`,
    /** 表格行 */
    tableRow: `${prefix}table-row`,
    /** 表头行 */
    tableHeaderRow: `${prefix}table-header-row`,
    /** 单元格 */
    tableCell: `${prefix}table-cell`,
    /** 表头的单元格 */
    tableHeaderCell: `${prefix}table-header-cell`,
    virtualBlank: `${prefix}virtual-blank`,
    stickyScroll: `${prefix}sticky-scroll`,
    stickyScrollItem: `${prefix}sticky-scroll-item`,
    /** 空白表格的（唯一）单元格 */
    emptyTableCell: `${prefix}empty-table-cell`,
    /** 数据为空时表格内容的外层 div */
    emptyWrapper: `${prefix}empty-wrapper`,
    emptyImage: `${prefix}empty-image`,
    emptyTips: `${prefix}empty-tips`,
    loadingWrapper: `${prefix}loading-wrapper`,
    loadingIndicatorWrapper: `${prefix}loading-indicator-wrapper`,
    loadingIndicator: `${prefix}loading-indicator`,
    loadingIndicatorIcon: `${prefix}loading-indicator-icon`,
    loadingContentWrapper: `${prefix}loading-content-wrapper`,
};
const Z = {
    lock: 20,
    scrollItem: 30,
    header: 5,
    virtual: 3,
    tableInner: 2,
    shadow: 1,
};
const ArtTableWrapper = styled__default.div `
  --color: #333;
  --bgcolor: white;
  --header-color: #5a6c84;
  --header-bgcolor: #e9edf2;
  --border-color: #dfe3e8;

  --row-height: 48px;
  --row-hover-color: #f5f5f5;
  --header-row-height: 32px;

  --cell-border: 1px solid var(--border-color);
  --cell-border-horizontal: var(--cell-border);
  --cell-border-vertical: var(--cell-border);

  --header-cell-border: 1px solid var(--border-color);
  --header-cell-border-horizontal: var(--header-cell-border);
  --header-cell-border-vertical: var(--header-cell-border);

  --cell-border-top: var(--cell-border-horizontal);
  --cell-border-bottom: var(--cell-border-horizontal);
  --cell-border-left: var(--cell-border-vertical);
  --cell-border-right: var(--cell-border-vertical);

  --header-cell-border-top: var(--header-cell-border-horizontal);
  --header-cell-border-bottom: var(--header-cell-border-horizontal);
  --header-cell-border-left: var(--header-cell-border-vertical);
  --header-cell-border-right: var(--header-cell-border-vertical);

  background: var(--bgcolor);
  box-sizing: border-box;
  * {
    box-sizing: border-box;
  }

  // 表格外边框由 art-table-wrapper 提供，而不是由单元格提供
  &.use-outer-border {
    border: 1px solid var(--border-color);

    .${Classes.tableCell}.first, .${Classes.tableHeaderCell}.first {
      border-left: none;
    }
    .${Classes.tableCell}.last, .${Classes.tableHeaderCell}.last {
      border-right: none;
    }
    .${Classes.tableHeaderRow}.first .${Classes.tableHeaderCell}, .${Classes.tableRow}.first .${Classes.tableCell} {
      border-top: none;
    }
    .${Classes.tableRow}.last .${Classes.tableCell} {
      border-bottom: none;
    }
  }

  // 表格 header 总是从 body 中同步滚动 scrollLeft
  .${Classes.tableHeader} {
    overflow: hidden;
  }

  .${Classes.virtualBlank} {
    background: var(--bgcolor);
    // 这里是为了遮盖 z-index=1 的 lock-shadow
    z-index: ${Z.virtual};
  }
`;
const MainSection = styled__default.div `
  // 表格的基本样式
  .${Classes.tableBody} {
    overflow: auto;
  }
  .${Classes.tableHeader} {
    overflow: hidden;
  }
`;
const EmptyTableCell = styled__default.td `
  height: 200px;

  .use-outer-border & {
    border: none;
  }
`;
const ArtTable = styled__default.div `
  // 表格的主要样式
  cursor: default;
  color: var(--color);
  font-size: 12px;
  line-height: 1.28571;
  position: relative;

  &.has-header {
    .${Classes.tableRow}.first td {
      border-top: none;
    }
  }

  &.sticky {
    .${Classes.tableHeaderWrapper} {
      position: sticky;
      top: 0;
      z-index: ${Z.header};
    }
  }

  .${Classes.tableHeaderWrapper} {
    background: var(--header-bgcolor);
  }

  .${Classes.tableRow} {
    &.hovered {
      background: var(--row-hover-color);
    }
  }

  table {
    width: 100%;
    table-layout: fixed;
    background: var(--bgcolor);
  }

  .${Classes.tableCell} {
    height: var(--row-height);
  }
  td,
  th {
    padding: 8px 12px;
    text-overflow: ellipsis;
    word-break: break-all;
    overflow: hidden;
  }

  // 表头单元格的基本样式
  th {
    height: var(--header-row-height);
    color: var(--header-color);
    font-weight: 400;
    background: var(--header-bgcolor);
    text-align: left;
  }

  // 表格的边框样式
  table {
    border-collapse: collapse;
    border-spacing: 0;
  }

  td {
    border-left: var(--cell-border-left);
    border-right: var(--cell-border-right);
    border-top: var(--cell-border-top);
    border-bottom: var(--cell-border-bottom);
  }

  th {
    border-left: var(--header-cell-border-left);
    border-right: var(--header-cell-border-right);
    border-top: var(--header-cell-border-top);
    border-bottom: var(--header-cell-border-bottom);
  }
`;
const LockSectionBase = styled__default.div `
  z-index: ${Z.lock};

  table {
    width: auto;
    overflow: hidden;
  }

  .${Classes.tableBody} {
    overflow: hidden;
  }
`;
const LeftSection = styled__default(LockSectionBase) `
  position: absolute;
  left: 0;
  top: 0;

  &.${Classes.lockShadow} {
    &::before {
      content: '';
      position: absolute;
      top: 6px;
      width: 10px;
      bottom: 6px;
      z-index: ${Z.shadow};
      right: 0;
      box-shadow: 0 0 5px 1px rgba(0, 0, 0, 0.3);
    }
    > .${Classes.tableInner} {
      position: relative;
      // 这里是为了遮盖 z-index=1 的 lock-shadow
      z-index: ${Z.tableInner};
    }
  }
`;
const RightSection = styled__default(LockSectionBase) `
  position: absolute;
  right: 0;
  top: 0;

  &.${Classes.lockShadow} {
    &::before {
      content: '';
      position: absolute;
      top: 6px;
      width: 10px;
      bottom: 6px;
      z-index: ${Z.shadow};
      left: 0;
      box-shadow: 0 0 5px 1px rgba(0, 0, 0, 0.3);
    }
    > .${Classes.tableInner} {
      position: relative;
      z-index: ${Z.tableInner};
    }
  }
`;
const EmptyWrapper = styled__default.div `
  color: #99a3b3;
  font-size: 12px;
  text-align: center;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);

  .${Classes.emptyImage} {
    width: 50px;
    height: 50px;
  }

  .${Classes.emptyTips} {
    margin-top: 16px;
    line-height: 1.5;
  }
`;
const StickyScroll = styled__default.div `
  overflow: auto;
  position: sticky;
  bottom: 0;
  z-index: ${Z.scrollItem};
  margin-top: -17px;

  .${Classes.stickyScrollItem} {
    // 必须有高度才能出现滚动条
    height: 1px;
    visibility: hidden;
  }
`;
const Styled = {
    ArtTableWrapper,
    ArtTable,
    MainSection,
    LeftSection,
    RightSection,
    StickyScroll,
    EmptyWrapper,
    EmptyTableCell,
};

EmptyTable.defaultProps = {
    emptyContent: (React.createElement(React.Fragment, null,
        React.createElement("img", { alt: "empty-image", className: Classes.emptyImage, src: "//img.alicdn.com/tfs/TB1l1LcM3HqK1RjSZJnXXbNLpXa-50-50.svg" }),
        React.createElement("div", { className: Classes.emptyTips },
            "\u6CA1\u6709\u7B26\u5408\u67E5\u8BE2\u6761\u4EF6\u7684\u6570\u636E",
            React.createElement("br", null),
            "\u8BF7\u4FEE\u6539\u6761\u4EF6\u540E\u91CD\u65B0\u67E5\u8BE2"))),
};
function EmptyTable({ colgroup, colSpan, isLoading, emptyContent, }) {
    return (React.createElement("table", null,
        colgroup,
        React.createElement("tbody", null,
            React.createElement("tr", null,
                React.createElement(Styled.EmptyTableCell, { className: Classes.emptyTableCell, colSpan: colSpan }, !isLoading && React.createElement(Styled.EmptyWrapper, { className: Classes.emptyWrapper }, emptyContent))))));
}

function isLeafNode(node) {
    return node.children == null || node.children.length === 0;
}

/** 遍历所有节点，并将节点收集到一个数组中.
 * order 参数可用于指定遍历规则：
 * * `pre` 前序遍历
 * * `post` 后续遍历
 * * `leaf-only` 忽略内部节点，只收集叶子节点
 * */
function collectNodes(nodes, order) {
    const result = [];
    dfs(nodes);
    return result;
    function dfs(nodes) {
        for (const node of nodes) {
            if (isLeafNode(node)) {
                result.push(node);
            }
            else {
                if (order === 'pre') {
                    result.push(node);
                    dfs(node.children);
                }
                else if (order === 'post') {
                    dfs(node.children);
                    result.push(node);
                }
                else {
                    dfs(node.children);
                }
            }
        }
    }
}

/** 获取一棵树的高度/深度 (0-based) */
function getTreeDepth(nodes) {
    let maxDepth = -1;
    dfs(nodes, 0);
    return maxDepth;
    function dfs(columns, depth) {
        for (const column of columns) {
            if (isLeafNode(column)) {
                maxDepth = Math.max(maxDepth, depth);
            }
            else {
                dfs(column.children, depth + 1);
            }
        }
    }
}

function groupBy(list, iteratee) {
    const groups = {};
    for (const item of list) {
        const key = iteratee(item);
        if (groups[key] == null) {
            groups[key] = [];
        }
        groups[key].push(item);
    }
    return groups;
}

function flatMap(array, callback) {
    const result = [];
    array.forEach((value, index) => {
        result.push(...callback(value, index, array));
    });
    return result;
}
function fromEntries(entries) {
    const result = {};
    for (const [key, value] of entries) {
        result[key] = value;
    }
    return result;
}

/** 在表格的单元格的渲染过程中，先渲染的单元格的 colSpan/rowSpan 会影响到后续单元格是否被渲染
 * `SpanManager` 会在内部维护一份状态来记录最近渲染单元格的 colSpan/rowSpan，
 * 方便后续的单元格快速判断 "是否需要跳过渲染" */
class SpanManager {
    constructor() {
        this.rects = [];
    }
    testSkip(rowIndex, colIndex) {
        return this.rects.some(({ left, right, top, bottom }) => left <= colIndex && colIndex < right && top <= rowIndex && rowIndex < bottom);
    }
    stripUpwards(rowIndex) {
        this.rects = this.rects.filter(rect => rect.bottom > rowIndex);
    }
    add(rowIndex, colIndex, colSpan, rowSpan) {
        this.rects.push({
            left: colIndex,
            right: colIndex + colSpan,
            top: rowIndex,
            bottom: rowIndex + rowSpan,
        });
    }
}

/** styled-components 类库的版本，ali-react-table 同时支持 v3 和 v5 */
const STYLED_VERSION = createGlobalStyle != null ? 'v5' : 'v3';
const STYLED_REF_PROP = STYLED_VERSION === 'v3' ? 'innerRef' : 'ref';
const OVERSCAN_SIZE = 100;
const LOADING_ICON_SIZE = 40;
const AUTO_VIRTUAL_THRESHOLD = 80;
function sum(arr) {
    let result = 0;
    arr.forEach((x) => {
        result += x;
    });
    return result;
}
function batchAdjustLeftCellSizes(leftTableRows, mainTableRows) {
    const leftRowCount = leftTableRows.length;
    // 批量获取 left-section 中每个单元格在 main-section 中对应单元格的尺寸
    const sizes = [];
    for (let i = 0; i < leftRowCount; i++) {
        const leftRow = leftTableRows.item(i);
        const leftCellCount = leftRow.cells.length;
        const mainRow = mainTableRows.item(i);
        for (let j = 0; j < leftCellCount; j++) {
            const cell = mainRow.cells.item(j);
            sizes.push({ h: cell.offsetHeight, w: cell.offsetWidth });
        }
    }
    // 批量设置 left-section 中的单元格的尺寸
    let n = 0;
    for (let i = 0; i < leftRowCount; i++) {
        const leftRow = leftTableRows.item(i);
        const cellCount = leftRow.cells.length;
        for (let j = 0; j < cellCount; j++) {
            const cell = leftRow.cells.item(j);
            const size = sizes[n];
            n += 1;
            cell.style.width = `${size.w}px`;
            cell.style.height = `${size.h}px`;
        }
    }
}
function batchAdjustRightCellSizes(rightTableRows, mainTableRows) {
    const rightRowCount = rightTableRows.length;
    // 批量获取 right-section 中每个单元格在 main-section 中对应单元格的尺寸
    // 获取尺寸时注意 right-section/main-section 是"靠右对齐"
    // 古下面代码中是"从右往左"迭代 main-section 中的单元格的
    const sizes = [];
    for (let i = 0; i < rightRowCount; i++) {
        const rightRow = rightTableRows.item(i);
        const rightCellCount = rightRow.cells.length;
        const mainRow = mainTableRows.item(i);
        const mainCellCount = mainRow.cells.length;
        for (let j = 0; j < rightCellCount; j++) {
            const mainCell = mainRow.cells.item(mainCellCount - 1 - j);
            sizes.push({ h: mainCell.offsetHeight, w: mainCell.offsetWidth });
        }
    }
    // 批量设置 right-section 中的单元格的尺寸
    let n = 0;
    for (let i = 0; i < rightRowCount; i++) {
        const rightRow = rightTableRows.item(i);
        const rightCellCount = rightRow.cells.length;
        for (let j = 0; j < rightCellCount; j++) {
            // 从右往左设置单元格尺寸
            const rightCell = rightRow.cells.item(rightCellCount - 1 - j);
            const size = sizes[n];
            n += 1;
            rightCell.style.width = `${size.w}px`;
            rightCell.style.height = `${size.h}px`;
        }
    }
}
// 使用 defer 避免过早引用 window，导致在 SSR 场景下报错
const throttledWindowResize$ = defer(() => fromEvent(window, 'resize').pipe(throttleTime(150, asyncScheduler, { leading: true, trailing: true })));
/** 获取默认的滚动条大小 */
function getScrollbarSizeImpl() {
    const scrollDiv = document.createElement('div');
    scrollDiv.style.position = 'absolute';
    scrollDiv.style.width = '100px';
    scrollDiv.style.height = '100px';
    scrollDiv.style.overflow = 'scroll';
    scrollDiv.style.top = '-9999px';
    document.body.appendChild(scrollDiv);
    const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    const scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;
    document.body.removeChild(scrollDiv);
    return { width: scrollbarWidth, height: scrollbarHeight };
}
let scrollBarSize$;
function getScrollbarSize() {
    if (scrollBarSize$ == null) {
        scrollBarSize$ = new BehaviorSubject(getScrollbarSizeImpl());
        throttledWindowResize$.pipe(map(() => getScrollbarSizeImpl())).subscribe(scrollBarSize$);
    }
    return scrollBarSize$.value;
}
/** 同步两个元素之间的 scrollLeft
 *  在 x.onScroll 中设置 y.scrollLeft 将会触发 y.onScroll (反之亦然)
 *  为了避免相互调用，在设置 scrollLeft 该方法会用 .skip 记录接下来需要忽略的 scroll 事件
 */
function syncScrollLeft(x, y) {
    const otherScrollTarget = (target) => {
        return target === 'x' ? 'y' : 'x';
    };
    const scrollSkipState$ = merge(fromEvent(x, 'scroll').pipe(mapTo('x')), fromEvent(y, 'scroll').pipe(mapTo('y'))).pipe(scan((acc, target) => {
        if (acc.skip === target) {
            return { skip: null, fire: false, target };
        }
        else {
            return { skip: otherScrollTarget(target), fire: true, target };
        }
    }, { skip: null, fire: false, target: null }));
    return scrollSkipState$.subscribe(({ fire, target }) => {
        if (fire) {
            if (target === 'x') {
                y.scrollLeft = x.scrollLeft;
            }
            else {
                x.scrollLeft = y.scrollLeft;
            }
        }
    });
}
function query(elem, className) {
    return elem === null || elem === void 0 ? void 0 : elem.querySelector('.' + className);
}
function queryAll(elem, className) {
    return elem === null || elem === void 0 ? void 0 : elem.querySelectorAll('.' + className);
}

function resolveVirtualEnabled(virtualEnum, defaultValue) {
    if (virtualEnum == null || virtualEnum === 'auto') {
        return defaultValue;
    }
    return virtualEnum;
}
/** 检查列配置 & 设置默认宽度 & 剔除隐藏的列 */
function processColumns(columns, defaultColumnWidth) {
    function dfs(columns) {
        const result = [];
        for (let column of columns) {
            if (column.width == null) {
                if (defaultColumnWidth != null) {
                    column = Object.assign(Object.assign({}, column), { width: defaultColumnWidth });
                }
                else if (process.env.NODE_ENV !== 'production' && isLeafNode(column) && column.lock) {
                    console.warn('锁列需要指定列宽度', column);
                }
            }
            if (isLeafNode(column)) {
                // 被隐藏的列 会在这里被剔除
                if (!column.hidden) {
                    result.push(column);
                }
            }
            else {
                const nextChildren = dfs(column.children);
                // 如果 nextChildren 为空，说明所有的子节点均被隐藏了，在这里隐藏父节点
                if (nextChildren.length > 0) {
                    result.push(Object.assign(Object.assign({}, column), { children: nextChildren }));
                }
            }
        }
        return result;
    }
    return dfs(columns);
}
function getLeftNestedLockCount(columns) {
    let nestedCount = 0;
    for (const col of columns) {
        if (isLock(col)) {
            nestedCount += 1;
        }
        else {
            break;
        }
    }
    return nestedCount;
    function isLock(col) {
        if (isLeafNode(col)) {
            return col.lock;
        }
        else {
            return col.lock || col.children.some(isLock);
        }
    }
}
function getDerivedStateFromProps(props, state) {
    const { useVirtual: useVirtualProp, columns: columnsProp, dataSource: dataSourceProp, defaultColumnWidth } = props;
    const columns = processColumns(columnsProp, defaultColumnWidth);
    const leftNestedLockCount = getLeftNestedLockCount(columns);
    const mainFlat = collectNodes(columns, 'leaf-only');
    if (leftNestedLockCount === columns.length) {
        // 处理所有的列均为 lock
        return {
            flat: { left: [], right: [], main: mainFlat, center: mainFlat },
            nested: { left: [], right: [], main: columns, center: columns },
            useVirtual: { horizontal: false, vertical: false, header: false },
        };
    }
    const leftNested = columns.slice(0, leftNestedLockCount);
    const rightNestedLockCount = getLeftNestedLockCount(columns.slice().reverse());
    const centerNested = columns.slice(leftNestedLockCount, columns.length - rightNestedLockCount);
    const rightNested = columns.slice(columns.length - rightNestedLockCount);
    const shouldEnableHozVirtual = mainFlat.length >= AUTO_VIRTUAL_THRESHOLD && mainFlat.every((col) => col.width != null);
    const shouldEnableVerVirtual = dataSourceProp.length >= AUTO_VIRTUAL_THRESHOLD;
    const useVirtual = typeof useVirtualProp !== 'object'
        ? {
            horizontal: resolveVirtualEnabled(useVirtualProp, shouldEnableHozVirtual),
            vertical: resolveVirtualEnabled(useVirtualProp, shouldEnableVerVirtual),
            header: resolveVirtualEnabled(useVirtualProp, false),
        }
        : {
            horizontal: resolveVirtualEnabled(useVirtualProp.horizontal, shouldEnableHozVirtual),
            vertical: resolveVirtualEnabled(useVirtualProp.vertical, shouldEnableVerVirtual),
            header: resolveVirtualEnabled(useVirtualProp.header, shouldEnableVerVirtual),
        };
    return {
        flat: {
            left: collectNodes(leftNested, 'leaf-only'),
            main: mainFlat,
            right: collectNodes(rightNested, 'leaf-only'),
            center: collectNodes(centerNested, 'leaf-only'),
        },
        nested: {
            left: leftNested,
            main: columns,
            right: rightNested,
            center: centerNested,
        },
        useVirtual,
    };
}

function range(n) {
    const array = [];
    for (let i = 0; i < n; i++) {
        array.push(i);
    }
    return array;
}
/** 根据当前横向虚拟滚动 对 nested.center 进行过滤，结果只保留当前视野内可见的那些列配置 */
function filterNestedCenter(centerNested, hoz, leftFlatCount) {
    return dfs(centerNested, leftFlatCount).filtered;
    function dfs(cols, startColIndex) {
        let leafCount = 0;
        const filtered = [];
        for (const col of cols) {
            const colIndex = startColIndex + leafCount;
            if (isLeafNode(col)) {
                leafCount += 1;
                if (leftFlatCount + hoz.leftIndex <= colIndex && colIndex < leftFlatCount + hoz.rightIndex) {
                    filtered.push({ colIndex, col });
                }
            }
            else {
                const dfsRes = dfs(col.children, colIndex);
                leafCount += dfsRes.leafCount;
                if (dfsRes.filtered.length > 0) {
                    filtered.push({ colIndex, col, children: dfsRes.filtered });
                }
            }
        }
        return { filtered, leafCount };
    }
}
/** 根据输入的 nested 列配置，算出相应的 leveled & flat 配置方便渲染 */
function calculateLeveledAndFlat(inputNested, rowCount) {
    const leveled = [];
    for (let depth = 0; depth < rowCount; depth++) {
        leveled.push([]);
    }
    const flat = [];
    dfs(inputNested, 0);
    return { flat, leveled };
    function dfs(input, depth) {
        let leafCount = 0;
        for (let i = 0; i < input.length; i++) {
            const indexedCol = input[i];
            if (isLeafNode(indexedCol)) {
                leafCount += 1;
                const wrapped = {
                    type: 'normal',
                    width: indexedCol.col.width,
                    col: indexedCol.col,
                    colIndex: indexedCol.colIndex,
                    colSpan: 1,
                    isLeaf: true,
                };
                leveled[depth].push(wrapped);
                flat.push(wrapped);
            }
            else {
                const dfsRes = dfs(indexedCol.children, depth + 1);
                leafCount += dfsRes.leafCount;
                if (dfsRes.leafCount > 0) {
                    leveled[depth].push({
                        type: 'normal',
                        width: indexedCol.col.width,
                        col: indexedCol.col,
                        colIndex: indexedCol.colIndex,
                        colSpan: dfsRes.leafCount,
                        isLeaf: false,
                    });
                }
            }
        }
        return { leafCount };
    }
}
/** 包装列配置，附加上 colIndex 属性 */
function attachColIndex(inputNested, colIndexOffset) {
    return dfs(inputNested, colIndexOffset).result;
    function dfs(input, startColIndex) {
        const result = [];
        let leafCount = 0;
        for (let i = 0; i < input.length; i++) {
            const col = input[i];
            const colIndex = startColIndex + leafCount;
            if (isLeafNode(col)) {
                leafCount += 1;
                result.push({ colIndex, col });
            }
            else {
                const sub = dfs(col.children, colIndex);
                leafCount += sub.leafCount;
                if (sub.leafCount > 0) {
                    result.push({ col, colIndex, children: sub.result });
                }
            }
        }
        return { result, leafCount };
    }
}
/** 计算用于渲染表头的数据结构 */
function calculateRenderInfo({ flat, nested, side, hoz, useVirtual }, rowCount) {
    if (side === 'main' && useVirtual.header) {
        const leftPart = calculateLeveledAndFlat(attachColIndex(nested.left, 0), rowCount);
        const filtered = filterNestedCenter(nested.center, hoz, flat.left.length);
        const centerPart = calculateLeveledAndFlat(filtered, rowCount);
        const rightPart = calculateLeveledAndFlat(attachColIndex(nested.right, flat.left.length + flat.center.length), rowCount);
        return {
            flat: [
                ...leftPart.flat,
                { type: 'blank', width: hoz.leftBlank, blankSide: 'left' },
                ...centerPart.flat,
                { type: 'blank', width: hoz.rightBlank, blankSide: 'right' },
                ...rightPart.flat,
            ],
            leveled: range(rowCount).map((depth) => [
                ...leftPart.leveled[depth],
                { type: 'blank', width: hoz.leftBlank, blankSide: 'left' },
                ...centerPart.leveled[depth],
                { type: 'blank', width: hoz.rightBlank, blankSide: 'right' },
                ...rightPart.leveled[depth],
            ]),
        };
    }
    const colIndexOffset = side === 'right' ? flat.left.length + flat.center.length : 0;
    return calculateLeveledAndFlat(attachColIndex(nested[side], colIndexOffset), rowCount);
}
function TableHeader(props) {
    const { nested, flat } = props;
    const colCount = flat.main.length;
    const rowCount = getTreeDepth(nested.main) + 1;
    const renderInfo = calculateRenderInfo(props, rowCount);
    const tbody = renderInfo.leveled.map((wrappedCols, level) => {
        const headerCells = wrappedCols.map((wrapped) => {
            var _a, _b;
            if (wrapped.type === 'normal') {
                const headerCellProps = (_a = wrapped.col.headerCellProps) !== null && _a !== void 0 ? _a : {};
                return (React.createElement("th", Object.assign({ key: wrapped.colIndex }, headerCellProps, { className: cx(Classes.tableHeaderCell, {
                        first: wrapped.colIndex === 0,
                        last: wrapped.colIndex + wrapped.colSpan === colCount,
                    }, headerCellProps.className), colSpan: wrapped.colSpan, rowSpan: wrapped.isLeaf ? rowCount - level : undefined, style: Object.assign({ textAlign: wrapped.col.align }, headerCellProps.style) }), (_b = wrapped.col.title) !== null && _b !== void 0 ? _b : wrapped.col.name));
            }
            else {
                if (wrapped.width > 0) {
                    return React.createElement("th", { key: wrapped.blankSide });
                }
                else {
                    return null;
                }
            }
        });
        return (React.createElement("tr", { key: level, className: cx(Classes.tableHeaderRow, {
                first: level === 0,
                last: level === rowCount - 1,
            }) }, headerCells));
    });
    return (React.createElement("div", { className: Classes.tableHeader },
        React.createElement("table", null,
            React.createElement("colgroup", null, renderInfo.flat.map((wrapped) => {
                if (wrapped.type === 'blank') {
                    if (wrapped.width > 0) {
                        return React.createElement("col", { key: wrapped.blankSide, style: { width: wrapped.width } });
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return React.createElement("col", { key: wrapped.colIndex, style: { width: wrapped.width } });
                }
            })),
            React.createElement("tbody", null, tbody))));
}

const ITEM_SIZE = 40;
class ItemSizeStore {
    constructor() {
        this.cache = [];
    }
    static getFullRenderRange(itemCount) {
        return {
            topIndex: 0,
            topBlank: 0,
            bottomIndex: itemCount,
            bottomBlank: 0,
        };
    }
    getRenderRangeWhenBelowView(itemCount) {
        const start = { topIndex: 0, topBlank: 0 };
        const end = this.getEnd(0, start, itemCount);
        return Object.assign(Object.assign({}, start), end);
    }
    getRenderRangeWhenAboveView(itemCount) {
        const totalSize = this.getEstimatedTotalSize(itemCount);
        const start = this.getStart(totalSize, itemCount);
        const end = this.getEnd(totalSize, start, itemCount);
        return Object.assign(Object.assign({}, start), end);
    }
    getRenderRangeWhenInView(offset, maxRenderHeight, itemCount) {
        const start = this.getStart(offset, itemCount);
        const end = this.getEnd(offset + maxRenderHeight, start, itemCount);
        return Object.assign(Object.assign({}, start), end);
    }
    binarySearchStart(searchOffset) {
        let min = 0;
        let max = this.cache.length - 1;
        while (min < max) {
            const middle = Math.ceil((min + max) / 2);
            const middleOffset = this.cache[middle].offset;
            if (middleOffset <= searchOffset) {
                min = middle;
            }
            else {
                max = middle - 1;
            }
        }
        return max;
    }
    /** 获取虚拟滚动在 开始位置上的信息 */
    getStart(offset, itemCount) {
        if (this.cache.length === 0) {
            return { topIndex: 0, topBlank: 0 };
        }
        const maxBottom = this.getMaxBottom();
        if (maxBottom < offset) {
            const lack = offset - maxBottom;
            // 快速滚动时，需要限制补足数量的最大值，防止元素数量超过 itemCount
            const maxLackCount = itemCount - this.cache.length;
            const lackCount = Math.min(Math.floor(lack / ITEM_SIZE), maxLackCount);
            // 中间缺失的直接使用 ITEM_SIZE 进行补足
            for (let i = 0, cntOffset = maxBottom; i < lackCount; i += 1, cntOffset += ITEM_SIZE) {
                this.cache.push({ offset: cntOffset, size: ITEM_SIZE });
            }
            const topIndex = this.cache.length - 1;
            const topBlank = this.cache[topIndex].offset;
            return this.overscanUpwards(topIndex, topBlank);
        }
        else {
            const topIndex = this.binarySearchStart(offset);
            const topBlank = this.cache[topIndex].offset;
            return this.overscanUpwards(topIndex, topBlank);
        }
    }
    overscanUpwards(topIndex, topBlank) {
        let overscanSize = 0;
        let overscanCount = 0;
        while (overscanCount < topIndex && overscanSize < OVERSCAN_SIZE) {
            overscanCount += 1;
            overscanSize += this.getItemSize(topIndex - overscanCount);
        }
        return {
            topIndex: topIndex - overscanCount,
            topBlank: topBlank - overscanSize,
        };
    }
    /** 获取虚拟滚动 在结束位置上的信息 */
    getEnd(endOffset, startInfo, itemCount) {
        let bottomIndex = startInfo.topIndex;
        let offset = startInfo.topBlank;
        while (bottomIndex < itemCount && offset < endOffset) {
            offset += this.getItemSize(bottomIndex);
            bottomIndex += 1;
        }
        const bottomBlank = this.getEstimatedTotalSize(itemCount) - offset;
        return this.overscanDownwards(bottomIndex, bottomBlank, itemCount);
    }
    overscanDownwards(bottomIndex, bottomBlank, itemCount) {
        let overscanSize = 0;
        let overscanCount = 0;
        while (overscanCount < itemCount - bottomIndex && overscanSize < OVERSCAN_SIZE) {
            overscanSize += this.getItemSize(bottomIndex + overscanCount);
            overscanCount += 1;
        }
        return {
            bottomIndex: bottomIndex + overscanCount,
            bottomBlank: bottomBlank - overscanSize,
        };
    }
    getItemSize(index) {
        return index < this.cache.length ? this.cache[index].size : ITEM_SIZE;
    }
    setMaxItemCount(itemCount) {
        if (itemCount < this.cache.length) {
            this.cache.length = itemCount;
        }
    }
    updateItem(index, offset, size) {
        this.cache[index] = { offset, size };
    }
    getEstimatedTotalSize(itemCount) {
        let measuredTotalSize = 0;
        let measuredCount = 0;
        const size = this.cache.length;
        if (size > 0) {
            const lastItem = this.cache[size - 1];
            measuredTotalSize = lastItem.offset + lastItem.size;
            measuredCount = size;
        }
        const unmeasuredTotalSize = (itemCount - measuredCount) * ITEM_SIZE;
        return measuredTotalSize + unmeasuredTotalSize;
    }
    getMaxBottom() {
        if (this.cache.length === 0) {
            return 0;
        }
        const item = this.cache[this.cache.length - 1];
        return item.offset + item.size;
    }
}

function getRect(ele) {
    if (ele === window) {
        return { left: 0, top: 0, bottom: window.innerHeight, right: window.innerWidth };
    }
    else {
        return ele.getBoundingClientRect();
    }
}
function getClipRect(target, flowRoot) {
    const targetRect = getRect(target);
    const rootRect = getRect(flowRoot);
    return {
        offsetY: Math.max(0, rootRect.top - targetRect.top),
        offsetX: Math.max(0, rootRect.left - targetRect.left),
        clipRect: {
            left: Math.max(targetRect.left, rootRect.left),
            top: Math.max(targetRect.top, rootRect.top),
            right: Math.min(targetRect.right, rootRect.right),
            bottom: Math.min(targetRect.bottom, rootRect.bottom),
        },
    };
}
/** 基于 ResizeObserver 和 scroll event 封装的 RxJS observable；
 * 用于监听一个元素的在页面中的「可见范围」的不断变化 */
class VisibleClipRectObservable extends Observable {
    constructor(target, flowRoot) {
        super((subscriber) => {
            const subscription = merge(fromEvent(flowRoot, 'scroll'), fromEvent(flowRoot, 'resize')).subscribe(callback);
            const resizeObserver = new ResizeObserver(callback);
            resizeObserver.observe(target);
            function callback() {
                subscriber.next(getClipRect(target, flowRoot));
            }
            return () => {
                subscription.unsubscribe();
                resizeObserver.disconnect();
            };
        });
    }
}

const LoadingIndicatorIcon = ({ size }) => (React.createElement("svg", { className: Classes.loadingIndicatorIcon, style: {
        margin: 'auto',
        display: 'block',
        shapeRendering: 'auto',
    }, width: size, height: size, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid" },
    React.createElement("circle", { cx: "50", cy: "50", r: "40", fill: "none", stroke: "#23a7fa", strokeDasharray: "188 64", strokeLinecap: "round", strokeWidth: "10" },
        React.createElement("animateTransform", { attributeName: "transform", dur: "1.5s", keyTimes: "0;1", repeatCount: "indefinite", type: "rotate", values: "0 50 50;360 50 50" }))));
Loading.defaultProps = {
    visible: true,
};
function Loading({ visible, children }) {
    return (React.createElement("div", { className: Classes.loadingWrapper, style: { position: 'relative' } },
        visible && (React.createElement("div", { className: Classes.loadingIndicatorWrapper, style: { position: 'absolute', left: 0, right: 0, top: 0, bottom: 0 } },
            React.createElement("div", { className: Classes.loadingIndicator, style: {
                    position: 'sticky',
                    zIndex: 1,
                    top: LOADING_ICON_SIZE,
                    left: 0,
                    right: 0,
                } },
                React.createElement(LoadingIndicatorIcon, { size: LOADING_ICON_SIZE })))),
        React.createElement("div", { className: Classes.loadingContentWrapper, style: { filter: visible ? 'blur(1px)' : 'none' } }, children)));
}

class BaseTable extends React.Component {
    constructor(props) {
        super(props);
        this.store = new ItemSizeStore();
        this.artTableRef = React.createRef();
        this.artTableWrapperRef = React.createRef();
        this.rootSubscription = new Subscription();
        this.hoveredTableRows = [];
        /**
         * 对于的锁定列和表头，因为我们对其设置了 overflow: hidden，导致在不会触发 scroll 事件。
         * 我们监听其 wheel 事件，然后手动同步 scrollTop/scrollLeft
         */
        this.onWheelInOverflowHiddenPart = (e) => {
            const { scrollLeft: x, scrollTop: y } = this.doms.mainBody;
            this.syncScroll(x + e.deltaX, y + e.deltaY);
        };
        this.syncScrollFromMainBody = () => {
            const { scrollLeft: x, scrollTop: y } = this.doms.mainBody;
            this.syncScroll(x, y);
        };
        this.onRowEnterOrLeave = (rowIndex, kind) => {
            var _a, _b;
            // 移除原先的 hover 效果
            this.hoveredTableRows.forEach((tr) => {
                tr.classList.remove('hovered');
            });
            if (kind === 'leave') {
                this.hoveredTableRows = [];
                return;
            }
            // 添加新的 hover 效果
            const rowSelector = `*[data-rowindex="${rowIndex}"]`;
            const mainRow = this.doms.mainBody.querySelector(rowSelector);
            const leftLockRow = (_a = this.doms.leftBody) === null || _a === void 0 ? void 0 : _a.querySelector(rowSelector);
            const rightLockRow = (_b = this.doms.rightBody) === null || _b === void 0 ? void 0 : _b.querySelector(rowSelector);
            this.hoveredTableRows = [mainRow, leftLockRow, rightLockRow].filter(Boolean);
            this.hoveredTableRows.forEach((tr) => {
                tr.classList.add('hovered');
            });
        };
        this.adjustSize = () => {
            this.adjustLoadingPosition();
            this.adjustNeedRenderLock();
            this.adjustSizeOfLockCells();
            this.adjustSizeOfLockBodies();
            this.adjustSizeOfLockHeaderCells();
        };
        this.state = Object.assign(Object.assign({}, getDerivedStateFromProps(props)), { hasScroll: true, needRenderLock: true, offsetY: 0, offsetX: 0, 
            // 因为 ResizeObserver 在一开始总是会调用一次所提供的回调函数
            // 故这里为 maxRenderHeight/maxRenderWidth 设置一个默认值即可（因为这两个默认值很快就会被覆盖）
            // https://stackoverflow.com/questions/60026223/does-resizeobserver-invokes-initially-on-page-load
            maxRenderHeight: 600, maxRenderWidth: 800 });
    }
    /** 自定义滚动条宽度为table宽度，使滚动条滑块宽度相同 */
    updateStickyScroll() {
        const { stickyScroll, mainBody, stickyScrollItem } = this.doms;
        if (!mainBody) {
            return;
        }
        const refTable = mainBody.querySelector('table');
        if (!refTable) {
            return;
        }
        const bodyWidth = mainBody.offsetWidth;
        const tableWidth = refTable.offsetWidth;
        const scrollbarSize = getScrollbarSize();
        stickyScroll.style.marginTop = `-${scrollbarSize.height}px`;
        // 如果有纵向滚动条，需要减少一个滚动条的宽度
        if (mainBody.scrollHeight > mainBody.clientHeight) {
            stickyScroll.style.width = `${bodyWidth - scrollbarSize.width}px`;
        }
        else {
            stickyScroll.style.width = 'auto';
        }
        if (bodyWidth >= tableWidth) {
            if (this.state.hasScroll) {
                this.setState({ hasScroll: false });
            }
            // 考虑下mac下面隐藏滚动条的情况
        }
        else if (!this.state.hasScroll && scrollbarSize.height > 5) {
            this.setState({ hasScroll: true });
        }
        // 设置子节点宽度
        stickyScrollItem.style.width = `${tableWidth}px`;
    }
    // 通过头部和扁平的结构渲染表格
    renderTableSection(side, renderRange) {
        const { hasHeader } = this.props;
        const onWheel = side !== 'main' ? this.onWheelInOverflowHiddenPart : null;
        const onScroll = side === 'main' ? this.syncScrollFromMainBody : null;
        return (React.createElement("div", { className: cx(Classes.tableInner) },
            hasHeader && this.renderTableHeader(side, renderRange),
            this.renderTableBody(side, renderRange, onWheel, onScroll)));
    }
    renderTableHeader(side, { horizontal: hoz }) {
        const { stickyTop } = this.props;
        const { flat, nested, useVirtual } = this.state;
        return (React.createElement("div", { className: cx(Classes.tableHeaderWrapper), style: { top: stickyTop }, onWheel: this.onWheelInOverflowHiddenPart },
            React.createElement(TableHeader, { nested: nested, flat: flat, hoz: hoz, side: side, useVirtual: useVirtual })));
    }
    updateOffsetX(nextOffsetX) {
        if (this.state.useVirtual.horizontal) {
            if (Math.abs(nextOffsetX - this.state.offsetX) >= OVERSCAN_SIZE / 2) {
                this.setState({ offsetX: nextOffsetX });
            }
        }
    }
    /** 同步滚动偏移量 */
    syncScroll(x, y) {
        this.updateOffsetX(x);
        const header = this.doms.mainHeader;
        const scrollNode = this.doms.mainBody;
        if (header) {
            header.scrollLeft = x;
        }
        scrollNode.scrollLeft = x;
        scrollNode.scrollTop = y;
        if (this.isLock()) {
            const { rightBody, leftBody, rightSection, leftSection } = this.doms;
            if (leftBody) {
                leftBody.scrollTop = y;
            }
            if (rightBody) {
                rightBody.scrollTop = y;
            }
            if (this.state.needRenderLock) {
                if (x <= 0) {
                    // 滚动条在最左端
                    leftSection === null || leftSection === void 0 ? void 0 : leftSection.classList.remove(Classes.lockShadow);
                    rightSection === null || rightSection === void 0 ? void 0 : rightSection.classList.add(Classes.lockShadow);
                }
                else if (x >= scrollNode.scrollWidth - scrollNode.clientWidth) {
                    // 滚动条在最右端
                    leftSection === null || leftSection === void 0 ? void 0 : leftSection.classList.add(Classes.lockShadow);
                    rightSection === null || rightSection === void 0 ? void 0 : rightSection.classList.remove(Classes.lockShadow);
                }
                else {
                    // 滚动条在中间
                    leftSection === null || leftSection === void 0 ? void 0 : leftSection.classList.add(Classes.lockShadow);
                    rightSection === null || rightSection === void 0 ? void 0 : rightSection.classList.add(Classes.lockShadow);
                }
            }
            else {
                // 不需要渲染 left-section / right-section
                leftSection === null || leftSection === void 0 ? void 0 : leftSection.classList.remove(Classes.lockShadow);
                rightSection === null || rightSection === void 0 ? void 0 : rightSection.classList.remove(Classes.lockShadow);
            }
        }
    }
    getVerticalRenderRange() {
        const { dataSource } = this.props;
        const { useVirtual, offsetY, maxRenderHeight } = this.state;
        const itemCount = dataSource.length;
        if (useVirtual.vertical) {
            if (maxRenderHeight <= 0) {
                // maxRenderHeight <= 0 说明表格目前在 viewport 之外
                if (offsetY <= 0) {
                    // 表格在 viewport 下方
                    return this.store.getRenderRangeWhenBelowView(itemCount);
                }
                else {
                    // 表格在 viewport 上方
                    return this.store.getRenderRangeWhenAboveView(itemCount);
                }
            }
            else {
                // 表格与 viewport 相交
                return this.store.getRenderRangeWhenInView(offsetY, maxRenderHeight, itemCount);
            }
        }
        else {
            return ItemSizeStore.getFullRenderRange(itemCount);
        }
    }
    getHorizontalRenderRange() {
        const { offsetX, maxRenderWidth, useVirtual, flat } = this.state;
        if (!useVirtual.horizontal) {
            return { leftIndex: 0, leftBlank: 0, rightIndex: flat.main.length, rightBlank: 0 };
        }
        let leftIndex = 0;
        let centerCount = 0;
        let leftBlank = 0;
        let centerRenderWidth = 0;
        const overscannedOffsetX = Math.max(0, offsetX - OVERSCAN_SIZE);
        while (leftIndex < flat.center.length) {
            const col = flat.center[leftIndex];
            if (col.width + leftBlank < overscannedOffsetX) {
                leftIndex += 1;
                leftBlank += col.width;
            }
            else {
                break;
            }
        }
        // 考虑 over scan 之后，中间部分的列至少需要渲染的宽度
        const minCenterRenderWidth = maxRenderWidth + (overscannedOffsetX - leftBlank) + 2 * OVERSCAN_SIZE;
        while (leftIndex + centerCount < flat.center.length) {
            const col = flat.center[leftIndex + centerCount];
            if (col.width + centerRenderWidth < minCenterRenderWidth) {
                centerRenderWidth += col.width;
                centerCount += 1;
            }
            else {
                break;
            }
        }
        const rightBlankCount = flat.center.length - leftIndex - centerCount;
        const rightBlank = sum(flat.center.slice(flat.center.length - rightBlankCount).map((col) => col.width));
        return {
            leftIndex: leftIndex,
            leftBlank,
            rightIndex: leftIndex + centerCount,
            rightBlank,
        };
    }
    getRenderRange() {
        return {
            vertical: this.getVerticalRenderRange(),
            horizontal: this.getHorizontalRenderRange(),
        };
    }
    getFlatHozWrappedCols(side, hoz) {
        const { flat } = this.state;
        if (side !== 'main') {
            const colIndexShift = side === 'right' ? flat.main.length - flat.right.length : 0;
            return flat[side].map((col, i) => ({ type: 'normal', col, colIndex: i + colIndexShift }));
        }
        const wrappedCols = [
            ...flat.left.map((col, i) => ({ type: 'normal', col, colIndex: i })),
            hoz.leftBlank > 0 && { type: 'blank', blankSide: 'left', width: hoz.leftBlank },
            ...flat.center
                .slice(hoz.leftIndex, hoz.rightIndex)
                .map((col, i) => ({ type: 'normal', col, colIndex: flat.left.length + hoz.leftIndex + i })),
            hoz.rightBlank > 0 && { type: 'blank', blankSide: 'right', width: hoz.rightBlank },
            ...flat.right.map((col, i) => ({ type: 'normal', col, colIndex: flat.main.length - flat.right.length + i })),
        ];
        return wrappedCols.filter(Boolean);
    }
    renderTableBody(side, renderRange, onWheel, onScroll) {
        const { onRowEnterOrLeave } = this;
        const { vertical: ver, horizontal: hoz } = renderRange;
        const { isLoading, dataSource, getRowProps, primaryKey, emptyContent } = this.props;
        const { flat } = this.state;
        const colCount = flat.main.length;
        const leftFlatCount = flat.left.length;
        const wrappedCols = this.getFlatHozWrappedCols(side, hoz);
        const colgroup = (React.createElement("colgroup", null, wrappedCols.map((wrapped) => {
            if (wrapped.type === 'blank') {
                return React.createElement("col", { key: wrapped.blankSide, style: { width: wrapped.width } });
            }
            return React.createElement("col", { key: wrapped.colIndex, style: { width: wrapped.col.width } });
        })));
        if (ver.bottomIndex - ver.topIndex === 0) {
            return (React.createElement("div", { className: Classes.tableBody, onWheel: onWheel, onScroll: onScroll },
                React.createElement(EmptyTable, { colgroup: colgroup, colSpan: wrappedCols.length, isLoading: isLoading, emptyContent: emptyContent })));
        }
        const spanManager = new SpanManager();
        const rows = dataSource.slice(ver.topIndex, ver.bottomIndex).map(renderRow);
        return (React.createElement("div", { className: Classes.tableBody, onWheel: onWheel, onScroll: onScroll },
            React.createElement("div", { key: "top-blank", className: cx(Classes.virtualBlank, 'top'), style: {
                    height: ver.topBlank,
                } }),
            React.createElement("table", null,
                colgroup,
                React.createElement("tbody", null, rows)),
            React.createElement("div", { key: "bottom-blank", className: cx(Classes.virtualBlank, 'bottom'), style: {
                    height: ver.bottomBlank,
                } })));
        function renderRow(record, i) {
            const rowIndex = ver.topIndex + i;
            spanManager.stripUpwards(rowIndex);
            const rowProps = getRowProps(record, rowIndex);
            const rowClass = cx(Classes.tableRow, {
                first: rowIndex === 0,
                last: rowIndex === dataSource.length - 1,
                even: rowIndex % 2 === 0,
                odd: rowIndex % 2 === 1,
            }, rowProps === null || rowProps === void 0 ? void 0 : rowProps.className);
            return (React.createElement("tr", Object.assign({}, rowProps, { className: rowClass, key: safeGetRowKey(primaryKey, record, rowIndex), "data-rowindex": rowIndex, onMouseEnter: (e) => {
                    var _a;
                    onRowEnterOrLeave(rowIndex, 'enter');
                    (_a = rowProps === null || rowProps === void 0 ? void 0 : rowProps.onMouseEnter) === null || _a === void 0 ? void 0 : _a.call(rowProps, e);
                }, onMouseLeave: (e) => {
                    var _a;
                    onRowEnterOrLeave(rowIndex, 'leave');
                    (_a = rowProps === null || rowProps === void 0 ? void 0 : rowProps.onMouseLeave) === null || _a === void 0 ? void 0 : _a.call(rowProps, e);
                } }), wrappedCols.map((wrapped) => {
                if (wrapped.type === 'blank') {
                    return React.createElement("td", { key: wrapped.blankSide });
                }
                return renderCell(record, rowIndex, wrapped.col, wrapped.colIndex);
            })));
        }
        function renderCell(record, rowIndex, column, colIndex) {
            var _a;
            if (spanManager.testSkip(rowIndex, colIndex)) {
                return null;
            }
            const cellProps = safeGetCellProps(column, record, rowIndex);
            let colSpan = 1;
            let rowSpan = 1;
            if (column.getSpanRect) {
                const value = safeGetValue(column, record, rowIndex);
                const spanRect = column.getSpanRect(value, record, rowIndex);
                colSpan = spanRect == null ? 1 : spanRect.right - colIndex;
                rowSpan = spanRect == null ? 1 : spanRect.bottom - rowIndex;
            }
            else {
                if (cellProps.colSpan != null) {
                    colSpan = cellProps.colSpan;
                }
                if (cellProps.rowSpan != null) {
                    rowSpan = cellProps.rowSpan;
                }
            }
            // rowSpan/colSpan 不能过大，避免 rowSpan/colSpan 影响因虚拟滚动而未渲染的单元格
            rowSpan = Math.min(rowSpan, ver.bottomIndex - rowIndex);
            colSpan = Math.min(colSpan, leftFlatCount + hoz.rightIndex - colIndex);
            const hasSpan = colSpan > 1 || rowSpan > 1;
            if (hasSpan) {
                spanManager.add(rowIndex, colIndex, colSpan, rowSpan);
            }
            const cls = cx(Classes.tableCell, {
                first: colIndex === 0,
                last: colIndex === colCount - 1,
            });
            if (column.align) {
                cellProps.style = (_a = cellProps.style) !== null && _a !== void 0 ? _a : {};
                cellProps.style.textAlign = column.align;
            }
            return React.createElement('td', Object.assign(Object.assign({ key: colIndex, className: cls }, cellProps), (hasSpan ? { colSpan, rowSpan } : null)), safeRender(column, record, rowIndex));
        }
    }
    isLock() {
        const { nested } = this.state;
        return nested.left.length > 0 || nested.right.length > 0;
    }
    render() {
        const { dataSource, className, style, hasHeader, useOuterBorder, isLoading, isStickyHead } = this.props;
        const styleWrapper = (node) => {
            const wrapperClassName = cx(Classes.artTableWrapper, className, {
                'use-outer-border': useOuterBorder,
            });
            const artTableWrapperProps = {
                className: wrapperClassName,
                style,
                [STYLED_REF_PROP]: this.artTableWrapperRef,
            };
            return React.createElement(Styled.ArtTableWrapper, Object.assign({}, artTableWrapperProps), node);
        };
        const withStickyScroll = (node) => (React.createElement(React.Fragment, null,
            node,
            React.createElement(Styled.StickyScroll, { className: Classes.stickyScroll, style: {
                    display: this.state.hasScroll ? 'block' : 'none',
                    bottom: this.props.stickyBottom,
                } },
                React.createElement("div", { className: Classes.stickyScrollItem }))));
        const loadingWrapper = (node) => {
            return React.createElement(Loading, { visible: isLoading }, node);
        };
        const tableClass = cx(Classes.artTable, {
            sticky: isStickyHead,
            empty: dataSource.length === 0,
            lock: this.isLock(),
            'has-header': hasHeader,
        });
        const renderRange = this.getRenderRange();
        const artTableProps = {
            className: tableClass,
            [STYLED_REF_PROP]: this.artTableRef,
        };
        const artTable = (React.createElement(Styled.ArtTable, Object.assign({}, artTableProps),
            this.renderLeftSection(renderRange),
            this.renderMainSection(renderRange),
            this.renderRightSection(renderRange)));
        return styleWrapper(withStickyScroll(loadingWrapper(artTable)));
    }
    renderLeftSection(renderRange) {
        const { dataSource } = this.props;
        const { nested, needRenderLock } = this.state;
        if (!needRenderLock || nested.left.length === 0 || dataSource.length === 0) {
            return null;
        }
        return (React.createElement(Styled.LeftSection, { className: Classes.leftSection }, this.renderTableSection('left', renderRange)));
    }
    renderMainSection(renderRange) {
        return (React.createElement(Styled.MainSection, { className: cx(Classes.mainSection) }, this.renderTableSection('main', renderRange)));
    }
    renderRightSection(renderRange) {
        const { dataSource } = this.props;
        const { nested, needRenderLock } = this.state;
        if (!needRenderLock || nested.right.length === 0 || dataSource.length === 0) {
            return null;
        }
        return (React.createElement(Styled.RightSection, { className: Classes.rightSection }, this.renderTableSection('right', renderRange)));
    }
    didMountOrUpdate(prevProps) {
        this.adjustSize();
        this.updateItemSizeStore(prevProps);
        this.syncScrollFromMainBody();
        this.updateStickyScroll();
    }
    componentDidMount() {
        this.updateDoms();
        this.didMountOrUpdate();
        this.initSubscriptions();
    }
    resolveFlowRoot() {
        const { flowRoot } = this.props;
        const wrapper = this.artTableWrapperRef.current;
        if (flowRoot === 'auto') {
            const computedStyle = getComputedStyle(wrapper);
            return computedStyle.overflowY !== 'visible' ? wrapper : window;
        }
        else if (flowRoot === 'self') {
            return wrapper;
        }
        else {
            return typeof flowRoot === 'function' ? flowRoot() : flowRoot;
        }
    }
    initSubscriptions() {
        const { mainBody, stickyScroll } = this.doms;
        this.rootSubscription.add(syncScrollLeft(mainBody, stickyScroll));
        this.rootSubscription.add(throttledWindowResize$.subscribe(() => {
            this.updateStickyScroll();
            this.adjustSize();
        }));
        // 在一些情况下 flowRoot 需要在父组件 didMount 时才会准备好
        // 故这里使用 requestAnimationFrame 等到下一个动画帧
        const rafId = requestAnimationFrame(() => {
            const resoledFlowRoot = this.resolveFlowRoot();
            const sizeAndOffset$ = new VisibleClipRectObservable(mainBody, resoledFlowRoot).pipe(filter(() => {
                const { horizontal, vertical } = this.state.useVirtual;
                return horizontal || vertical;
            }), map(({ clipRect, offsetY }) => ({
                maxRenderHeight: clipRect.bottom - clipRect.top,
                maxRenderWidth: clipRect.right - clipRect.left,
                offsetY,
            })), distinctUntilChanged((x, y) => {
                // 因为 overscan 的存在，滚动较小的距离时不需要触发组件重渲染
                return (Math.abs(x.maxRenderWidth - y.maxRenderWidth) < OVERSCAN_SIZE / 2 &&
                    Math.abs(x.maxRenderHeight - y.maxRenderHeight) < OVERSCAN_SIZE / 2 &&
                    Math.abs(x.offsetY - y.offsetY) < OVERSCAN_SIZE / 2);
            }));
            this.rootSubscription.add(sizeAndOffset$.subscribe((sizeAndOffset) => {
                this.setState(sizeAndOffset);
            }));
        });
        this.rootSubscription.add(() => {
            cancelAnimationFrame(rafId);
        });
    }
    componentDidUpdate(prevProps) {
        this.updateDoms();
        this.didMountOrUpdate(prevProps);
    }
    componentWillUnmount() {
        this.rootSubscription.unsubscribe();
    }
    /** 更新 DOM 节点的引用，方便其他方法直接操作 DOM */
    updateDoms() {
        const artTableWrapper = this.artTableWrapperRef.current;
        const artTable = this.artTableRef.current;
        const mainSection = query(artTable, Classes.mainSection);
        const leftSection = query(artTable, Classes.leftSection);
        const rightSection = query(artTable, Classes.rightSection);
        this.doms = {
            artTableWrapper,
            artTable,
            mainSection,
            mainHeader: query(mainSection, Classes.tableHeader),
            mainBody: query(mainSection, Classes.tableBody),
            leftSection,
            leftHeader: query(leftSection, Classes.tableHeader),
            leftBody: query(leftSection, Classes.tableBody),
            rightSection,
            rightHeader: query(rightSection, Classes.tableHeader),
            rightBody: query(rightSection, Classes.tableBody),
            stickyScroll: query(artTableWrapper, Classes.stickyScroll),
            stickyScrollItem: query(artTableWrapper, Classes.stickyScrollItem),
        };
    }
    updateItemSizeStore(prevProps) {
        var _a;
        if (prevProps != null) {
            if (prevProps.dataSource.length !== this.props.dataSource.length) {
                this.store.setMaxItemCount(this.props.dataSource.length);
            }
        }
        const virtualTop = this.doms.mainBody.querySelector(`.${Classes.virtualBlank}.top`);
        const virtualTopHeight = (_a = virtualTop === null || virtualTop === void 0 ? void 0 : virtualTop.clientHeight) !== null && _a !== void 0 ? _a : 0;
        queryAll(this.doms.mainBody, Classes.tableRow).forEach((tr) => {
            const rowIndex = Number(tr.dataset.rowindex);
            this.store.updateItem(rowIndex, tr.offsetTop + virtualTopHeight, tr.offsetHeight);
        });
    }
    adjustLoadingPosition() {
        const { mainSection, artTableWrapper } = this.doms;
        const loadingIndicator = query(artTableWrapper, Classes.loadingIndicator);
        if (!loadingIndicator) {
            return;
        }
        const { clipRect } = getClipRect(mainSection, this.resolveFlowRoot());
        const height = clipRect.bottom - clipRect.top;
        loadingIndicator.style.top = `${height / 2 - LOADING_ICON_SIZE / 2}px`;
        loadingIndicator.style.marginTop = `${height / 2 - LOADING_ICON_SIZE / 2}px`;
    }
    // 同步左右两侧锁列的单元格高度
    adjustSizeOfLockCells() {
        if (!this.isLock()) {
            return;
        }
        const mainTableRows = queryAll(this.doms.mainBody, Classes.tableRow);
        if (this.doms.leftBody) {
            const leftTableRows = queryAll(this.doms.leftBody, Classes.tableRow);
            batchAdjustLeftCellSizes(leftTableRows, mainTableRows);
        }
        if (this.doms.rightBody) {
            const rightTableRows = queryAll(this.doms.rightBody, Classes.tableRow);
            batchAdjustRightCellSizes(rightTableRows, mainTableRows);
        }
    }
    adjustSizeOfLockBodies() {
        if (this.isLock()) {
            const { mainBody, rightSection } = this.doms;
            let width = 0;
            if (mainBody.scrollHeight > mainBody.clientHeight) {
                width = getScrollbarSize().width;
            }
            rightSection && (rightSection.style.right = `${width}px`);
        }
    }
    /** 更新左右两侧锁列表头的 tr 的高度 */
    adjustSizeOfLockHeaderCells() {
        if (!this.isLock()) {
            return;
        }
        const mainTableRows = queryAll(this.doms.mainHeader, Classes.tableHeaderRow);
        if (this.doms.leftHeader) {
            const leftTableRows = queryAll(this.doms.leftHeader, Classes.tableHeaderRow);
            batchAdjustLeftCellSizes(leftTableRows, mainTableRows);
        }
        if (this.doms.rightHeader) {
            const rightTableRows = queryAll(this.doms.rightHeader, Classes.tableHeaderRow);
            batchAdjustRightCellSizes(rightTableRows, mainTableRows);
        }
    }
    /** 计算表格所有列的渲染宽度之和，判断表格是否需要渲染锁列 */
    adjustNeedRenderLock() {
        let nextNeedRenderLock;
        const { dataSource } = this.props;
        const { needRenderLock } = this.state;
        const { mainBody, artTable } = this.doms;
        if (this.isLock() && dataSource.length > 0) {
            const firstRow = query(mainBody, Classes.tableRow);
            if (firstRow == null) {
                // fixme 理论上 firstRow 不为 null，但实际情况下非常低概率还是会出现为 null 的情况
                return;
            }
            const sumOfColWidth = Array.from(firstRow.cells).reduce((sum, cell) => {
                return sum + cell.offsetWidth;
            }, 0);
            nextNeedRenderLock = sumOfColWidth > artTable.clientWidth;
        }
        else {
            nextNeedRenderLock = false;
        }
        if (needRenderLock !== nextNeedRenderLock) {
            this.setState({ needRenderLock: nextNeedRenderLock });
        }
    }
}
BaseTable.defaultProps = {
    isStickyHead: true,
    stickyTop: 0,
    stickyBottom: 0,
    useVirtual: 'auto',
    hasHeader: true,
    isLoading: false,
    getRowProps: noop,
    flowRoot: 'auto',
};
BaseTable.getDerivedStateFromProps = getDerivedStateFromProps;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/**
 * Copyright IBM Corp. 2018, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  // Reference:
  // https://github.com/IBM/carbon-components-react/issues/1392
  // https://github.com/PolymerElements/iron-iconset-svg/pull/47
  // `focusable` is a string attribute which is why we do not use a boolean here
  focusable: 'false',
  preserveAspectRatio: 'xMidYMid meet'
};
/**
 * Get supplementary HTML attributes for a given <svg> element based on existing
 * attributes.
 */

function getAttributes() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      width = _ref.width,
      height = _ref.height,
      _ref$viewBox = _ref.viewBox,
      viewBox = _ref$viewBox === void 0 ? "0 0 ".concat(width, " ").concat(height) : _ref$viewBox,
      attributes = _objectWithoutProperties(_ref, ["width", "height", "viewBox"]);

  var tabindex = attributes.tabindex,
      rest = _objectWithoutProperties(attributes, ["tabindex"]);

  var iconAttributes = _objectSpread2(_objectSpread2(_objectSpread2({}, defaultAttributes), rest), {}, {
    width: width,
    height: height,
    viewBox: viewBox
  }); // TODO: attributes.title assumes that the consumer will implement <title> and
  // correctly set `aria-labelledby`.


  if (iconAttributes['aria-label'] || iconAttributes['aria-labelledby'] || iconAttributes.title) {
    iconAttributes.role = 'img'; // Reference:
    // https://allyjs.io/tutorials/focusing-in-svg.html

    if (tabindex !== undefined && tabindex !== null) {
      iconAttributes.focusable = 'true';
      iconAttributes.tabindex = tabindex;
    }
  } else {
    iconAttributes['aria-hidden'] = true;
  }

  return iconAttributes;
}

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties$1(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$1(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var Icon = /*#__PURE__*/React.forwardRef(function Icon(_ref, ref) {
  var className = _ref.className,
      children = _ref.children,
      tabIndex = _ref.tabIndex,
      rest = _objectWithoutProperties$1(_ref, ["className", "children", "tabIndex"]);

  var _getAttributes = getAttributes(_objectSpread2$1(_objectSpread2$1({}, rest), {}, {
    tabindex: tabIndex
  })),
      tabindex = _getAttributes.tabindex,
      props = _objectWithoutProperties$1(_getAttributes, ["tabindex"]);

  if (className) {
    props.className = className;
  }

  if (tabindex !== undefined && tabindex !== null) {
    props.tabIndex = tabindex;
  }

  if (ref) {
    props.ref = ref;
  }

  return /*#__PURE__*/React.createElement('svg', props, children);
});
Icon.displayName = 'Icon';
Icon.propTypes = {
  'aria-hidden': PropTypes.string,
  'aria-label': PropTypes.string,
  'aria-labelledby': PropTypes.string,
  className: PropTypes.string,
  children: PropTypes.node,
  height: PropTypes.number,
  preserveAspectRatio: PropTypes.string,
  tabIndex: PropTypes.string,
  viewBox: PropTypes.string,
  width: PropTypes.number,
  xmlns: PropTypes.string
};
Icon.defaultProps = {
  xmlns: 'http://www.w3.org/2000/svg',
  preserveAspectRatio: 'xMidYMid meet'
};

/**
 * Copyright IBM Corp. 2019, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */

var _ref2 =
/*#__PURE__*/

/*#__PURE__*/
React.createElement("path", {
  d: "M12 8L22 16 12 24z"
});

var CaretRight16 = /*#__PURE__*/React.forwardRef(function CaretRight16(_ref, ref) {
  var children = _ref.children,
      rest = _objectWithoutProperties$1(_ref, ["children"]);

  return /*#__PURE__*/React.createElement(Icon, _extends({
    width: 16,
    height: 16,
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    ref: ref
  }, rest), _ref2, children);
});

const ExpansionCell = styled__default.div `
  display: flex;
  align-items: center;
  cursor: pointer;
  height: 100%;
  padding: 0 12px;

  &.leaf {
    cursor: default;
  }

  .expansion-icon {
    fill: #999;
    flex: 0 0 16px;
    transition: transform 200ms;

    &.expanded {
      transform-origin: center center;
      transform: rotate(90deg);
    }
  }
`;
const treeMetaSymbol = Symbol('treeMetaSymbol');
const ICON_WIDTH = 16;
const BASE_INDENT = 10;
function makeTreeModeTransform({ onChangeOpenKeys, openKeys, primaryKey, indentSize = 16, isLeafNode: isLeafNode$1 = isLeafNode, }) {
    const openKeySet = new Set(openKeys);
    return ({ columns, dataSource }) => {
        return {
            columns: processColumns(columns),
            dataSource: processDataSource(dataSource),
        };
        function processDataSource(input) {
            const result = [];
            dfs(input, 0);
            function dfs(nodes, depth) {
                if (nodes == null) {
                    return;
                }
                for (const node of nodes) {
                    const rowKey = node[primaryKey];
                    const expanded = openKeySet.has(rowKey);
                    const isLeaf = isLeafNode$1(node, { depth, expanded, rowKey });
                    const treeMeta = { depth, isLeaf, expanded, rowKey };
                    result.push(Object.assign({ [treeMetaSymbol]: treeMeta }, node));
                    if (!isLeaf && expanded) {
                        dfs(node.children, depth + 1);
                    }
                }
            }
            return result;
        }
        function processColumns(columns) {
            if (columns.length === 0) {
                return columns;
            }
            const [firstCol, ...others] = columns;
            const render = (value, record, recordIndex) => {
                const content = safeRender(firstCol, record, recordIndex);
                if (record[treeMetaSymbol] == null) {
                    // 没有 treeMeta 信息的话，就返回原先的渲染结果
                    return content;
                }
                const { depth, isLeaf, rowKey, expanded } = record[treeMetaSymbol];
                if (isLeaf) {
                    return (React.createElement(ExpansionCell, { className: "expansion-cell leaf" },
                        React.createElement("span", { style: { marginLeft: BASE_INDENT + depth * indentSize } }, content)));
                }
                const marginLeft = -ICON_WIDTH + BASE_INDENT + depth * indentSize;
                if (expanded) {
                    return (React.createElement(ExpansionCell, { className: "expansion-cell expanded", onClick: () => {
                            onChangeOpenKeys(openKeys.filter((key) => key !== rowKey), rowKey, 'collapse');
                        } },
                        React.createElement(CaretRight16, { className: "expansion-icon expanded", style: { marginLeft } }),
                        content));
                }
                else {
                    return (React.createElement(ExpansionCell, { className: "expansion-cell collapsed", onClick: () => {
                            onChangeOpenKeys([...openKeys, rowKey], rowKey, 'expand');
                        } },
                        React.createElement(CaretRight16, { className: "expansion-icon collapsed", style: { marginLeft } }),
                        content));
                }
            };
            const getCellProps = (value, record, rowIndex) => {
                if (firstCol.getCellProps) {
                    const prevProps = firstCol.getCellProps(value, record, rowIndex);
                    return Object.assign(Object.assign({}, prevProps), { style: Object.assign(Object.assign({}, prevProps === null || prevProps === void 0 ? void 0 : prevProps.style), { padding: 0 }) });
                }
                return { style: { padding: 0 } };
            };
            return [Object.assign(Object.assign({}, firstCol), { render, getCellProps }), ...others];
        }
    };
}
function useTreeModeTransform({ isLeafNode, indentSize, primaryKey, defaultOpenKeys = [], }) {
    const [openKeys, onChangeOpenKeys] = useState(defaultOpenKeys);
    return makeTreeModeTransform({ indentSize, primaryKey, isLeafNode, openKeys, onChangeOpenKeys });
}

export { BaseTable as B, Classes as C, Icon as I, SpanManager as S, __rest as _, groupBy as a, isLeafNode as b, collectNodes as c, safeGetCellProps as d, safeRenderHeader as e, flatMap as f, getTreeDepth as g, _objectWithoutProperties$1 as h, internals as i, _extends as j, STYLED_VERSION as k, fromEntries as l, makeTreeModeTransform as m, CaretRight16 as n, safeGetValue as s, treeMetaSymbol as t, useTreeModeTransform as u };
